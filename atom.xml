<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vvVB0</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-15T13:59:26.407Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CLL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>洛谷-题单-字符串入门</title>
    <link href="http://example.com/posts/c7172a2b.html"/>
    <id>http://example.com/posts/c7172a2b.html</id>
    <published>2024-10-01T14:06:56.000Z</published>
    <updated>2024-10-15T13:59:26.407Z</updated>
    
    <content type="html"><![CDATA[<p>题目：自动修正<br><img src="/image.png" alt="alt text"><br>#include <iostream><br>#include <string><br>using namespace std;</p><p>int main(){<br>    string s;<br>    cin&gt;&gt;s;<br>    for(int i &#x3D; 0; i &lt; s.length();i++){<br>        s[i] &#x3D; toupper(s[i]);<br>    }<br>    cout&lt;&lt;s;<br>    return 0;<br>}<br>错误原因：<br>1.不会转大小写<br>A 的ASCII为 66 （小） a的ASCII为98 （大）差32<br>把小写转换成大写就是：<br>if(a[i]&gt;&#x3D;’a’ &amp;&amp; a[i]&lt;&#x3D;’z’)<br>{<br>    a[i]&#x3D;a[i]-‘a’+’A’;  &#x2F;&#x2F;a[i]&#x3D;a[i]- (‘a’ - A)<br>}<br>把大写转换成小写就是：</p><p>if(a[i]&gt;&#x3D;’A’ &amp;&amp; a[i]&lt;&#x3D;’Z’)<br>{<br>    a[i]&#x3D;a[i]-‘A’+’a’;<br>}</p><p>题目:小书童-凯撒密码<br><img src="/image.png" alt="alt text"><br>c++<br>最终版本：<br>#include <iostream><br>#include <string><br>using namespace std;</p><p>int main(){<br>    string s;<br>    int n;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    if(n &gt;0&amp;&amp;n &lt;27){<br>        for(int i &#x3D; 0; i &lt; s.length();i++){<br>            if (islower(s[i])) {    &#x2F;&#x2F;islower(s[i]) 是一个函数调用，用于检查字符 s[i] 是否为小写字母<br>                s[i] &#x3D; ‘a’ + (s[i] - ‘a’ + n) % 26; &#x2F;&#x2F;string 约等于 char[],所以可用数组的方法<br>            }<br>        }<br>    }<br>    cout&lt;&lt;s;<br>    return 0;<br>}</p><p>c语言<br>#include &lt;stdio.h&gt;</p><p>int main(){<br>    int n;<br>    char str[100];<br>    scanf(“%d%s”,&amp;n,str);<br>    for(int i &#x3D; 0; str[i] !&#x3D; ‘\0’;i++){<br>        str[i] &#x3D; ‘a’ + (str[i] - ‘a’ + n) % 26; &#x2F;&#x2F; 也可写为 putchar((in[j]-‘a’+n)%26+’a’);<br>    }<br>    printf(“%s”,str); &#x2F;&#x2F;使没有显式使用第二个循环来输出字符串，但由于 C 语言的特性，C 字符串以 null 结尾（即以 \0 结尾），printf(“%s”, str); 会一直输出字符直到遇到 null 终止符为止。<br>    return 0;<br>}</p><p>错误原因：<br>1.没有想到z跳完之后要转到a的情况<br>2.没有想到检测小写，而是直接转小写，不符合题意<br>3.(str[i] - ‘a’ + n)写成(‘a’ - str[i]  + n) 小- 大导致错误<br>重点：<br>1.s[i] &#x3D; ‘a’ + (s[i] - ‘a’ + n) % 26;<br>这行代码是用来实现对小写字母进行向后移动 n 位的操作。让我们解释一下这行代码的具体功能：<br>s[i] - ‘a’：这部分计算了当前字符 s[i] 相对于小写字母表中的字母 ‘a’ 的偏移量。<br>(s[i] - ‘a’ + n)：这一部分将偏移量加上移动的位数 n，以实现向后移动的效果。<br>(s[i] - ‘a’ + n) % 26：由于小写字母表只有 26 个字母，因此这一部分确保结果在 0 到 25 之间，以便在字母表上循环移动。<br>‘a’ + (s[i] - ‘a’ + n) % 26：最后，将结果映射回小写字母表，得到移动后的字符。<br>2.putchar()<br>putchar()是一个 C 语言标准库函数，用于将一个字符输出到标准输出流（通常是控制台）<br>eg:putchar(66) &#x3D; printf(“A”)</p><p>必学方法：确保结果在 0 到 25 之间，利用 % 26得到!!!!!!</p><p>3.题目<br><img src="/image.png" alt="alt text"><br>代码：<br>正确版本：<br>#include <iostream><br>#include <string><br>#include <cmath></p><p>using namespace std;</p><p>bool isPrime(int num) {<br>    if (num &lt;&#x3D; 1) return false;<br>    for (int i &#x3D; 2; i &lt;&#x3D; sqrt(num); i++) {<br>        if (num % i &#x3D;&#x3D; 0) return false;<br>    }<br>    return true;<br>}</p><p>int main() {<br>    string str;<br>    cin &gt;&gt; str;<br>    int n[26] &#x3D; {0};</p><pre><code>// 统计每个字母出现的次数for (char c : str) &#123;    n[c - &#39;a&#39;]++;&#125;int maxn = 0, minn = 100;  // 初始化minn为一个较大值// 找到最大和最小的非零频率for (int i = 0; i &lt; 26; i++) &#123;    if (n[i] &gt; 0) &#123;        if (n[i] &gt; maxn) maxn = n[i];        if (n[i] &lt; minn) minn = n[i];    &#125;&#125;int z = maxn - minn;// 根据z的值判断输出if (isPrime(z)) &#123;    cout &lt;&lt; &quot;Lucky Word&quot; &lt;&lt; endl &lt;&lt; z;&#125; else &#123;    cout &lt;&lt; &quot;No Answer&quot; &lt;&lt; endl &lt;&lt; 0;&#125;return 0;</code></pre><p>}<br>错误版本：<br>#include <iostream><br>#include <string><br>#include<algorithm><br>#include <cmath></p><p>using namespace std;</p><p>int main(){<br>    string str;<br>    cin&gt;&gt;str;<br>    int n[25] &#x3D; {0};<br>    int z;<br>    for(int i &#x3D; 0; i &lt; str.size(); i++){<br>        n[str[i] - ‘a’]++;<br>    }<br>    sort(n, n + 26);<br>    &#x2F;*for(int i &#x3D; 0; i &lt; 26; i++){<br>        cout&lt;&lt;n[i];<br>    }*&#x2F;<br>    for(int i &#x3D; 0; i &lt; 26; i++){<br>        if(n[i] &gt; 0){<br>            z &#x3D; n[25] - n[i];<br>            break;<br>        }<br>    }<br>    if(z &#x3D;&#x3D; 2 || z&#x3D;&#x3D;3){<br>        cout&lt;&lt;”Lucky Word”;<br>    }<br>    else if(z &#x3D;&#x3D; 0||z &#x3D;&#x3D; 1){<br>        cout&lt;&lt;”No Answer”;<br>    }<br>    else{<br>        int c &#x3D; 0;<br>        for(int i &#x3D; 2; i &lt;&#x3D; sqrt(z);i++){<br>            if(z % i &#x3D;&#x3D; 0){<br>                c &#x3D; 1;<br>                break;<br>            }<br>        }<br>        if(c &#x3D;&#x3D; 1) cout&lt;&lt;”No Answer”;<br>        else cout&lt;&lt;”Lucky Word”;<br>    }<br>    cout&lt;&lt;endl&lt;&lt;z;<br>    return 0;<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：自动修正&lt;br&gt;&lt;img src=&quot;/image.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;#include &lt;iostream&gt;&lt;br&gt;#include &lt;string&gt;&lt;br&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;int main(){&lt;b</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>洛谷-题单-字符串入门</title>
    <link href="http://example.com/posts/c7172a2b.html"/>
    <id>http://example.com/posts/c7172a2b.html</id>
    <published>2024-10-01T14:06:56.000Z</published>
    <updated>2024-10-15T13:59:26.415Z</updated>
    
    <content type="html"><![CDATA[<p>C语言字符串函数：头文件：#include &lt;string.h&gt;<br>1.stpcpy<br>作用：复制字符串<br>用法：stpcpy(目标串变量,被复制字符串变量);<br>2.strcat<br>作用：拼接字符串<br>用法：strcat(目标串变量,被拼接字符串变量)<br>3.strchr<br>作用：<br>用法：<br>4.<br>作用：<br>用法：<br>5.<br>作用：<br>用法：</p><p>C++知识点<br>一.string类<br>作用：约等于char,是 C++用来代替 char 数组的数据结构,且是动态变化的，不用对大小进行约束</p><p>结构：是一个类，为一个顺序表，类的内部封装了char*</p><p>在使用string类时，必须包含 #include 头文件以及  using namespace std</p><p>用法：<br>一. string的构造函数的形式：<br>string str：生成空字符串</p><p>string s(str)：生成字符串为str的复制品</p><p>string s(str, strbegin,strlen)：将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</p><p>string s(cstr, char_len)：以C_string类型cstr的前char_len个字符串作为字符串s的初值</p><p>string s(num ,c)：生成num个c字符的字符串</p><p>string s(str, stridx)：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</p><p>eg:</p><pre><code>string str1;               //生成空字符串string str2(&quot;123456789&quot;);  //生成&quot;1234456789&quot;的复制品string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot;string str4(&quot;012345&quot;, 5);  //结果为&quot;01234&quot;string str5(5, &#39;1&#39;);       //结果为&quot;11111&quot;string str6(str2, 2);      //结果为&quot;3456789&quot;二. string的大小和容量：</code></pre><ol><li><p>size()和length()：返回string对象的字符个数，他们执行效果相同。</p></li><li><p>max_size()：返回string对象最多包含的字符数，超出会抛出length_error异常</p></li><li><p>capacity()：重新分配内存之前，string对象能包含的最大字符数<br>void test2()<br>{<br> string s(“1234567”);<br> cout &lt;&lt; “size&#x3D;” &lt;&lt; s.size() &lt;&lt; endl;<br> cout &lt;&lt; “length&#x3D;” &lt;&lt; s.length() &lt;&lt; endl;<br> cout &lt;&lt; “max_size&#x3D;” &lt;&lt; s.max_size() &lt;&lt; endl;<br> cout &lt;&lt; “capacity&#x3D;” &lt;&lt; s.capacity() &lt;&lt; endl;</p></li></ol><p>}<br>三. string的字符串比较：</p><ol><li><p>C ++字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。<br>在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，<br>比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小(前面减后面)<br>同时，string (“aaaa”) &lt;string(aaaaa)。    </p></li><li><p>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。<br>  他返回一个整数来表示比较结果，返回值意义如下：0：相等 1：大于 -1：小于 (A的ASCII码是65，a的ASCII码是97)<br>  void test3()<br>{<br> &#x2F;&#x2F; (A的ASCII码是65，a的ASCII码是97)<br> &#x2F;&#x2F; 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0<br> string A(“aBcd”);<br> string B(“Abcd”);<br> string C(“123456”);<br> string D(“123dfg”);</p><p> &#x2F;&#x2F; “aBcd” 和 “Abcd”比较—— a &gt; A<br> cout &lt;&lt; “A.compare(B)：” &lt;&lt; A.compare(B)&lt;&lt; endl;                          &#x2F;&#x2F; 结果：1</p><p> &#x2F;&#x2F; “cd” 和 “Abcd”比较——- c &gt; A<br> cout &lt;&lt; “A.compare(2, 3, B):” &lt;&lt;A.compare(2, 3, B)&lt;&lt; endl;                &#x2F;&#x2F; 结果：1</p><p> &#x2F;&#x2F; “cd” 和 “cd”比较<br> cout &lt;&lt; “A.compare(2, 3, B, 2, 3):” &lt;&lt; A.compare(2, 3, B, 2, 3) &lt;&lt; endl;  &#x2F;&#x2F; 结果：0</p><p> &#x2F;&#x2F; 由结果看出来：0表示下标，3表示长度<br> &#x2F;&#x2F; “123” 和 “123”比较<br> cout &lt;&lt; “C.compare(0, 3, D, 0, 3)” &lt;&lt;C.compare(0, 3, D, 0, 3) &lt;&lt; endl;    &#x2F;&#x2F; 结果：0</p></li></ol><p>}<br>四. string的插入：push_back() 和 insert()<br>void  test4()<br>{<br>    string s1;</p><pre><code>// 尾插一个字符s1.push_back(&#39;a&#39;);s1.push_back(&#39;b&#39;);s1.push_back(&#39;c&#39;);cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:abc// insert(pos,char):在制定的位置pos前插入字符chars1.insert(s1.begin(),&#39;1&#39;);cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:1abc</code></pre><p>}<br>五、string拼接字符串：append() &amp; + 操作符<br>void test5()<br>{<br>    &#x2F;&#x2F; 方法一：append()<br>    string s1(“abc”);<br>    s1.append(“def”);<br>    cout&lt;&lt;”s1:”&lt;&lt;s1&lt;&lt;endl; &#x2F;&#x2F; s1:abcdef</p><pre><code>// 方法二：+ 操作符string s2 = &quot;abc&quot;;/*s2 += &quot;def&quot;;*/string s3 = &quot;def&quot;;s2 += s3.c_str();cout&lt;&lt;&quot;s2:&quot;&lt;&lt;s2&lt;&lt;endl; // s2:abcdef</code></pre><p>}<br>六、 string的遍历：借助迭代器 或者 下标法<br>void test6()<br>{<br>    string s1(“abcdef”); &#x2F;&#x2F; 调用一次构造函数</p><pre><code>// 方法一： 下标法for( int i = 0; i &lt; s1.size() ; i++ )&#123;    cout&lt;&lt;s1[i];&#125;cout&lt;&lt;endl;// 方法二：正向迭代器string::iterator iter = s1.begin();for( ; iter &lt; s1.end() ; iter++)&#123;    cout&lt;&lt;*iter;&#125;cout&lt;&lt;endl;// 方法三：反向迭代器string::reverse_iterator riter = s1.rbegin();for( ; riter &lt; s1.rend() ; riter++)&#123;    cout&lt;&lt;*riter;&#125;cout&lt;&lt;endl;</code></pre><p>}<br>七、 string的删除：erase()</p><ol><li><p>iterator erase(iterator p);&#x2F;&#x2F;删除字符串中p所指的字符</p></li><li><p>iterator erase(iterator first, iterator last);&#x2F;&#x2F;删除字符串中迭代器</p></li></ol><p>区间[first,last)上所有字符</p><ol start="3"><li>string&amp; erase(size_t pos &#x3D; 0, size_t len &#x3D; npos);&#x2F;&#x2F;删除字符串中从索引</li></ol><p>位置pos开始的len个字符</p><ol start="4"><li><p>void clear();&#x2F;&#x2F;删除字符串中所有字符<br>void test6()<br>{<br> string s1 &#x3D; “123456789”;</p><p> &#x2F;&#x2F; s1.erase(s1.begin()+1);              &#x2F;&#x2F; 结果：13456789<br> &#x2F;&#x2F; s1.erase(s1.begin()+1,s1.end()-2);   &#x2F;&#x2F; 结果：189<br> s1.erase(1,6);                       &#x2F;&#x2F; 结果：189<br> string::iterator iter &#x3D; s1.begin();<br> while( iter !&#x3D; s1.end() )<br> {<br> cout&lt;&lt;*iter;<br> *iter++;<br> }<br> cout&lt;&lt;endl;</p></li></ol><p>}<br>八、 string的字符替换：</p><ol><li>string&amp; replace(size_t pos, size_t n, const char *s);&#x2F;&#x2F;将当前字符串</li></ol><p>从pos索引开始的n个字符，替换成字符串s</p><ol start="2"><li><p>string&amp; replace(size_t pos, size_t n, size_t n1, char c); &#x2F;&#x2F;将当前字符串从pos索引开始的n个字符，替换成n1个字符c</p></li><li><p>string&amp; replace(iterator i1, iterator i2, const char* s);&#x2F;&#x2F;将当前字符串[i1,i2)区间中的字符串替换为字符串s<br>void test7()<br>{<br> string s1(“hello,world!”);</p><p> cout&lt;&lt;s1.size()&lt;&lt;endl;                     &#x2F;&#x2F; 结果：12<br> s1.replace(s1.size()-1,1,1,’.’);           &#x2F;&#x2F; 结果：hello,world.</p><p> &#x2F;&#x2F; 这里的6表示下标  5表示长度<br> s1.replace(6,5,”girl”);                    &#x2F;&#x2F; 结果：hello,girl.<br> &#x2F;&#x2F; s1.begin(),s1.begin()+5 是左闭右开区间<br> s1.replace(s1.begin(),s1.begin()+5,”boy”); &#x2F;&#x2F; 结果：boy,girl.<br> cout&lt;&lt;s1&lt;&lt;endl;</p></li></ol><p>}<br>九、 string的大小写转换：tolower()和toupper()函数 或者 STL中的transform算法<br>法一：使用C语言之前的方法，使用函数，进行转换<br>#include <iostream><br>#include <string><br>using namespace std;</p><p>int main()<br>{<br>    string s &#x3D; “ABCDEFG”;</p><pre><code>for( int i = 0; i &lt; s.size(); i++ )&#123;    s[i] = tolower(s[i]);&#125;cout&lt;&lt;s&lt;&lt;endl;return 0;</code></pre><p>}<br>法二：通过STL的transform算法配合的toupper和tolower来实现该功能<br>#include <iostream><br>#include <algorithm><br>#include <string></p><p>using namespace std;</p><p>int main()<br>{<br>    string s &#x3D; “ABCDEFG”;<br>    string result;</p><pre><code>transform(s.begin(),s.end(),s.begin(),::tolower);cout&lt;&lt;s&lt;&lt;endl;return 0;</code></pre><p>}<br>十、 string的查找：find</p><ol><li>size_t find (constchar* s, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，</p><pre><code>-1表示查找不到子串</code></pre><ol start="2"><li>size_t find (charc, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，</p><pre><code>-1表示查找不到字符</code></pre><ol start="3"><li>size_t rfind (constchar* s, size_t pos &#x3D; npos) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，</p><pre><code>-1表示查找不到子串</code></pre><ol start="4"><li>size_t rfind (charc, size_t pos &#x3D; npos) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</p><ol start="5"><li>size_tfind_first_of (const char* s, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><ol start="6"><li>size_tfind_first_not_of (const char* s, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><ol start="7"><li>size_t find_last_of(const char* s, size_t pos &#x3D; npos) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><ol start="8"><li>size_tfind_last_not_of (const char* s, size_t pos &#x3D; npos) const;</li></ol><p> &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串<br> void test8()<br>{<br>    string s(“dog bird chicken bird cat”);</p><pre><code>//字符串查找-----找到后返回首字母在字符串中的下标// 1. 查找一个字符串cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;        // 结果是：9// 2. 从下标为6开始找字符&#39;i&#39;，返回找到的第一个i的下标cout &lt;&lt; s.find(&#39;i&#39;,6) &lt;&lt; endl;            // 结果是：11// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;       // 结果是：9// 4. 从字符串的末尾开始查找字符cout &lt;&lt; s.rfind(&#39;i&#39;) &lt;&lt; endl;             // 结果是：18-------因为是从末尾开始查找，所以返回第一次找到的字符// 5. 在该字符串中查找第一个属于字符串s的字符cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;  // 结果是：4---b// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9// 7. 在该字符串最后中查找第一个属于字符串s的字符cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;               // 结果是：19// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;            // 结果是：21</code></pre><p>}<br>十一、 string的排序：sort(s.begin(),s.end())<br>#include <iostream><br>#include <algorithm><br>#include <string><br>using namespace std;</p><p>void test9()<br>{<br>    string s &#x3D; “cdefba”;<br>    sort(s.begin(),s.end());<br>    cout&lt;&lt;”s:”&lt;&lt;s&lt;&lt;endl;     &#x2F;&#x2F; 结果：abcdef<br>}<br>十二、 string的分割&#x2F;截取字符串：strtok() &amp; substr()<br>void test10()<br>{<br>    char str[] &#x3D; “I,am,a,student; hello world!”;</p><pre><code>const char *split = &quot;,; !&quot;;char *p2 = strtok(str,split);while( p2 != NULL )&#123;    cout&lt;&lt;p2&lt;&lt;endl;    p2 = strtok(NULL,split);&#125;</code></pre><p>}<br>void test11()<br>{<br>    string s1(“0123456789”);<br>    string s2 &#x3D; s1.substr(2,5); &#x2F;&#x2F; 结果：23456—–参数5表示：截取的字符串的长度<br>    cout&lt;&lt;s2&lt;&lt;endl;<br>}</p><p>二.相应头文件<br>1.using namespace std; :<br>引入命名空间 std 中的所有符号，这样在代码中就可以直接使用标准库中的函数、类、对象等，而不需要在每个标准库的成员前面加上 std:: 前缀<br>2.#include<cstring><br>提供了一些用于处理字符串的函数，比如字符串复制、连接、比较等。这个头文件通常用于 C 风格的字符串操作。<br>3.#include<iostream><br>它提供了 C++ 标准输入输出流的支持。包含这个头文件可以让你在程序中使用标准的输入输出流，比如 std::cout 和 std::cin<br>4.#include<cstdio><br>提供了一些函数来进行输入和输出操作，比如 printf 和 scanf。这个头文件通常用于 C 风格的输入输出操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C语言字符串函数：头文件：#include &amp;lt;string.h&amp;gt;&lt;br&gt;1.stpcpy&lt;br&gt;作用：复制字符串&lt;br&gt;用法：stpcpy(目标串变量,被复制字符串变量);&lt;br&gt;2.strcat&lt;br&gt;作用：拼接字符串&lt;br&gt;用法：strcat(目标串变量,被</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeeCode-02-跳跃游戏</title>
    <link href="http://example.com/posts/871adf45.html"/>
    <id>http://example.com/posts/871adf45.html</id>
    <published>2024-09-26T14:06:56.000Z</published>
    <updated>2024-09-28T14:11:31.307Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：<br>解题：<br>法一：超越时间限制<br>bool canJump(int<em> nums, int numsSize) {<br>    /</em><br>    题目理解：<br>    目的：从nums[0]跳到nums[numsSize - 1] 约束：跳跃长度jumplength &lt;= nums[pos] pos:当前数组元素下标<br>    目标：如果可以达到目的 跳跃次数 越少越好 否则输出false<br>    特殊点：<br>    1.nums[pos] = 0 &amp;&amp; pos &lt; numsSize - 1<br>    2.不满足跳到最后的条件：<br>        1&gt; 总会到达跳跃长度为0的下标<br>    思路：<br>    1.跳过nums[pos] = 0 &amp;&amp; pos &lt; numsSize - 1的数组元素<br>    2.减少跳跃次数</p><pre><code>思路2：判断如何从nums[0]跳到跳跃长度为0的下标，能找到输出false,否则输出true1.遍历数组，找到nums[pos] = 0的pos思路3：只要能找到一条跳到nums[numsSize - 1]的路，能找到输出true,否则输出false1.pos = 0 从nums[pos]开始，每次跳跃nums[pos]，2.如果nums[pos] = 0 回到上一个位置space    if nums[space] &gt;= 2 则 pos = pos + nums[pos] - 1,否则继续退到上一个位置3.如果pos + nums[pos] &gt;= numsSize - 1 返回true*/if(nums[0] == 0 &amp;&amp; numsSize != 1)&#123;    return false;&#125;else if(nums[0] == 0 &amp;&amp; numsSize == 1)&#123;    return true;&#125;int pos = 0;int amount = 0;while(pos &lt;= numsSize - 1 &amp;&amp; pos &gt;= 0)&#123;    int space = nums[pos];  //  记录上一次走的步长    pos = pos + nums[pos];    amount++;    if(pos &lt; numsSize - 1 &amp;&amp; nums[pos] == 0 )&#123;        if(space &gt; 1 &amp;&amp; amount &gt; 0)&#123;            pos = pos - space - 1;        &#125;        else&#123;            if(amount &gt; 0)&#123;                pos = pos - 1;                amount--;            &#125;            for(int i = amount; i &gt; 0; i--)&#123;                pos = pos - nums[i];                if(pos &gt;= 0 &amp;&amp; nums[pos] &gt; 1)&#123;                    pos = pos + nums[pos] - 1;                &#125;                else if (pos = 0)&#123;                    return false;                &#125;            &#125;        &#125;    &#125;&#125;if(pos &gt;= numsSize - 1)&#123;    return true;&#125;else&#123;    return false;&#125;</code></pre><p>}<br>法二：<br>bool canJump(int<em> nums, int numsSize) {<br>    /</em>思路：<br>        目的：跳到最后一个元素numsSize - 1，只要能跳跃的最大长度大于等于numsSize - 1就能到达<br>    */<br>    if(numsSize == 1){<br>        return  true;<br>    }<br>    int reachmax = 0;<br>    for(int i = 0; i &lt; numsSize - 1; i++){<br>        if(nums[i] == 0 &amp;&amp; reachmax &lt;= i){<br>            return false;<br>        }<br>        reachmax =  reachmax &gt; i + nums[i] ? reachmax : i + nums[i];<br>        if(reachmax &gt;= numsSize - 1){<br>            return true;<br>        }<br>    }<br>    return false;<br>}<br>体会：<br>利用贪心算法寻找局部最优解<br>具体做法：每走一步就找寻一次最优解，直至找到最后<br>例如，在该问题中，走到index 0，更新一次能够走的最大距离，继续顺序走index 2，判断在index 2能走的最大距离，以此类推</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目描述：&lt;br&gt;解题：&lt;br&gt;法一：超越时间限制&lt;br&gt;bool canJump(int&lt;em&gt; nums, int numsSize) {&lt;br&gt;    /&lt;/em&gt;&lt;br&gt;    题目理解：&lt;br&gt;    目的：从nums[0]跳到nums[numsSize - 1]</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeeCode 01-坐上公交的最晚时间</title>
    <link href="http://example.com/posts/828b5000.html"/>
    <id>http://example.com/posts/828b5000.html</id>
    <published>2024-09-22T14:06:56.000Z</published>
    <updated>2024-09-28T14:07:54.493Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p><p>给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。</p><p>每位乘客都会排队搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y &lt;= x  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。</p><p>返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。</p><p>注意：数组 buses 和 passengers 不一定是有序的。</p><p>示例：<br>示例 1：</p><p>输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2<br>输出：16<br>解释：<br>第 1 辆公交车载着第 1 位乘客。<br>第 2 辆公交车载着你和第 2 位乘客。<br>注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。<br>示例 2：</p><p>输入：buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2<br>输出：20<br>解释：<br>第 1 辆公交车载着第 4 位乘客。<br>第 2 辆公交车载着第 6 位和第 2 位乘客。<br>第 3 辆公交车载着第 1 位乘客和你。</p><p>提示：</p><p>n == buses.length<br>m == passengers.length<br>1 &lt;= n, m, capacity &lt;= 105<br>2 &lt;= buses[i], passengers[i] &lt;= 109<br>buses 中的元素 互不相同 。<br>passengers 中的元素 互不相同 。</p><p>本人做法：<br>int latestTimeCatchTheBus(int<em> buses, int busesSize, int</em> passengers, int passengersSize, int capacity) {<br>   /*<br>   总思路</p><ol><li>排序 将buses,passages数组从小到大排序</li><li>最晚时间到达 即<br>1&gt; 选择到达时间最晚的公交 即下标为N-1的数组<br>2&gt; 按照乘客到达的时间从早到晚依次将busessize-1量公交车乘客安排完毕<br>3&gt; 继续安排最后一辆公交车的乘客<br><em>/<br>/</em><br>子问题一 排序 冒泡排序<br>1.依次比较i i+1两个元素的大小<br>1.1 若i &gt; i + 1,返回1<br>1.2 若i &lt; i + 1,交换二者位置<br>2.循环 n - 1 <em> n - 1次</em>/<br>/<em><br>问题二 安排乘客<br>1.从下标i = 0 i&lt;busesSize-2 外层,j = 0 内层 开始<br>2.若</em>(buses + i)&gt;*(passengers + j)</li><li>j+1 z+1</li><li><p>z==capacity或乘客不符合条件 i + 1<br>*/</p><p>int time; //最晚到达时间<br>int lasttime; //原本最后一位乘客的抵达时间</p><p>for(int j = 0; j &lt; busesSize - 1; j++) {  //公交车抵达时间排序<br>for(int i = 0; i &lt; busesSize - 1 - j; i++) {<br>  if(<em>(buses + i) &lt; </em>(buses + i + 1)) {</p><pre><code>  continue;</code></pre><p>  }<br>  else {</p><pre><code>  int z = *(buses + i);  *(buses + i) = *(buses + i + 1);  *(buses + i + 1) = z;</code></pre><p>  }<br>}<br>}<br>for(int j = 0; j &lt; passengersSize - 1; j++) {    //乘客到达时间排序<br>for(int i = 0; i &lt; passengersSize - 1 - j; i++) {<br>  if(<em>(passengers + i) &lt; </em>(passengers + i + 1)) {</p><pre><code>  continue;</code></pre><p>  }<br>  else {</p><pre><code>  int z = *(passengers + i);  *(passengers + i) = *(passengers + i + 1);  *(passengers + i + 1) = z;</code></pre><p>  }<br>}<br>}<br>int j1 = 0;<br>int i = 0;<br>int q = capacity;<br>for(i = 0; i &lt;= busesSize-2; i++){  //除最后一辆车外安排好其余乘客 j表示倒数第二辆车的最后一位乘客下标<br>  for(q = capacity; q &gt; 0; q—){</p><pre><code>  if(*(passengers + j1) &lt; *(buses + i))&#123;   //如果乘客到达时间小于公交车到达时间      j1++;  &#125;  else&#123;      break;  &#125;</code></pre><p>  }<br>}<br>int j = j1 - 1;</p><p>if(passengersSize - j1 &gt;=capacity){<br>  for(int c = capacity; c &gt; 0; c—){</p><pre><code>  if(*(passengers + j + c) - 1 != *(passengers + j + c - 1))&#123;      time = *(passengers + j + c) - 1;      break;  &#125;  else if(c == 1)&#123;      time = *(passengers + j + 1) - 1;  //极端情况，安排乘客抵达时间在第一个乘客前      break;  &#125;</code></pre><p>  }<br>}</p><p>return time;</p></li></ol><p>}</p><p>官方解答：<br>int compare(const void <em>a, const void </em>b) {<br>    return (<em>(int</em>)a - <em>(int</em>)b);<br>}</p><p>int latestTimeCatchTheBus(int<em> buses, int busesSize, int</em> passengers, int passengersSize, int capacity) {<br>    qsort(buses, busesSize, sizeof(int), compare);  //公交车到达时间排序<br>    qsort(passengers, passengersSize, sizeof(int), compare);    //乘客到达时间排序<br>    int pos = 0;    //第pos位乘客上车<br>    int space = 0;  //公交车容量</p><pre><code>for (int i = 0; i &lt; busesSize; i++) &#123;    int arrive = buses[i];  //第i（从0开始计数）量车情况    space = capacity;   //每辆公交车初始容量为capacity    while (space &gt; 0 &amp;&amp; pos &lt; passengersSize &amp;&amp; passengers[pos] &lt;= arrive) &#123;        //乘客上车条件：如果剩余容量&gt;0,还有乘客未走，以及乘客抵达时间&lt;=公交车到达时间        //反之若不满足任意条件，即，该辆公交车容量已满，或已经没有乘客，或乘客到达时间晚于公交车时间，跳出循环，转为下一辆车        space--;        pos++;        //在比较完下标为0的乘客时，pos = 1,已经指向下一位乘客数组下标，所以比到最后一位时，pos的值也会比下标大1，代表走了第几位（1开始计数）乘客    &#125;&#125;pos--;  //指向最后一位上车乘客的元素int lastCatchTime = space &gt; 0 ? buses[busesSize - 1] : passengers[pos];//space也可代表最后一辆公交车的剩余容量情况while (pos &gt;= 0 &amp;&amp; passengers[pos] == lastCatchTime) &#123;    pos--;    lastCatchTime--;&#125;return lastCatchTime;</code></pre><p>}</p><p>代码解读：</p><p>qsort — 用于数组排序的函数 英语quick sort快速排序<br>一、头文件 </p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdlib.h></h1><p>二、格式<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(int</em>)a-<em>(int</em>)b;<br>}<br>qsort(num, n, sizeof(int), cmp);<br>包含四个参数(数组名, 数组长度，数组元素数据类型所占字节，排序原则)<br>使用方法：<br>定义一个函数cmp(自命名)，通过cmp返回的参数确定排序规则，其中cmp函数的参数需要以(const void <em>a,consi void </em>b)的形式定义，表示a,b变量的数据类型未知，在return返回时，用强制类型转换转换为int型，<em>(int</em>)a - <em>(int</em>)b 表示递增顺序,同理，<em>(int</em>)b - <em>(int</em>)a 表示递减顺序<br>排序原则：<br>根据要排序数组元素数据类型的不同，可分为四种<br>1.int型<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(int</em>)a-<em>(int</em>)b;<br>}<br>2.double型<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(double</em>)a&gt;<em>(double</em>)b?1:-1;<br>}<br>需要注意浮点数会存在精度损失的问题，所以我们需要通过比较，来返回1或-1，以确定是增序还是降序。<br>3.char型<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(char</em>)a-<em>(char</em>)b;<br>}<br>4.结构体型<br>struct node{<br>    int i;<br>    double j;<br>    char k;<br>};<br>int cmp(const void <em>a,const void </em>b) {<br>    return (<em>(node</em>)a).i-(<em>(node</em>)b).i;<br>}<br>深度剖析：<br>void qsort(void<em> base, //指向了待排序数组的第一个元素<br>           size_t num,   //待排序的元素个数<br>           size_t size, //每个元素的大小，单位是字节<br>           int (</em> cmp)(const void<em>, const void</em>) //指向一个函数，这个函数可以比较2个元素的大小<br>          );<br>返回类型void:我们改变的是数列的排序，实际只需要进行内存的操作，所以不需要返回值。<br>void<em> base:表示应传入初始地址，至于为什么是void类型，它不知道我们会传入什么数据，而void类型就像一个垃圾桶一样什么地址都可以仍进去，所以只能用void</em>类型。<br>size_t num:num数量，表示应传入的元素个数<br>size_t width:width宽度，表示应传入的每个元素占的字节大小<br>int (<em>cmp)(const void </em>, const void *):<br>应传入一个比较函数地址，用于比较两个数据的大小，因为传入的数据类型是不确定的，所以我们需要自己定义一个比较函数传到qsort比较函数里面去，以便它知道怎么样去比较两个数据的大小。</p><p>qsort可以排序任意类型的数据<br>比较2个整数的大小，&gt; &lt; ==<br>比较2个字符串的大小，strcmp<br>比较2个结构体数据（学生：张三，李四）指定比较的标准</p><p>const void <em>a<br>关键字 const<br>作用：用const修饰的变量或对象的值不能再被改变<br>根据数据类型的不同分为：<br>1.修饰普通变量<br>const int n=5;<br>注意：用const修饰变量时，一定要给变量初始化，否则之后不能再进行赋值<br>int const n=5;<br>两种情况，n的值都不能再被改变<br>2.修饰指针<br>    1&gt;常量指针：指针指向的内容是常量<br>        const int </em> n;<br>        int const <em> n;<br>    注意：仅仅指 指针指向的内容为常量，相当于，常量指针指向哪个变量，哪个变量的值不能被改变，但是不能通过这个指针改变变量的值，但还是可以通过其他的引用来改变变量的值 【存疑-那常量指针的意义在哪】<br>        int a=5;<br>        const int</em> n=&a;<br>        a=6;<br>    2&gt;指针常量：指针自己是常量，即只能指向一个地址，但指向的内容可以改变<br>        int a=5;<br>        int <em>p=&a;<br>        int</em> const n=&a;<br>        <em>p=8;<br>区分指针常量，常量指针：字面翻译<br>    const int </em> n; 先常量后指针，常量指针<br>    int* const n=&a; 先指针后常量，指针常量，指针（是）常量</p><p><em>(int</em>)a-<em>(int</em>)b<br>    (int*)a :强制类型转换，将a的数据类型强制转换成整型指针<br>    强制类型转换：(type_name) expression 即 (要转换的目标类型)被转换的变量或表达式</p><p>学习心得：<br>循环条件有顺序，eg:while (pos &gt;= 0 &amp;&amp; passengers[pos] == lastCatchTime) 判断完第一个条件符合后才进行第二个条件<br>所以必要的边界条件先写，再写后面的逻辑约束条件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题描述：给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法-01-贪心算法1-Djikstra算法</title>
    <link href="http://example.com/posts/90b623e1.html"/>
    <id>http://example.com/posts/90b623e1.html</id>
    <published>2024-09-22T14:06:56.000Z</published>
    <updated>2024-09-28T14:10:36.208Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法:寻找局部最优解<br>大概有两种方法：Djikstra算法（迪杰斯特拉算法） 最小生成树Prim算法<br>Djikstra算法 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;贪心算法:寻找局部最优解&lt;br&gt;大概有两种方法：Djikstra算法（迪杰斯特拉算法） 最小生成树Prim算法&lt;br&gt;Djikstra算法 &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/posts/4a17b156.html"/>
    <id>http://example.com/posts/4a17b156.html</id>
    <published>2024-09-11T09:24:37.714Z</published>
    <updated>2024-09-16T11:52:42.615Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
