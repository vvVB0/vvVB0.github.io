<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vvVB0</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-19T13:58:14.649Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CLL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3.红色和紫色</title>
    <link href="http://example.com/posts/c6f25b8.html"/>
    <id>http://example.com/posts/c6f25b8.html</id>
    <published>2024-10-19T13:51:10.285Z</published>
    <updated>2024-10-19T13:58:14.649Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/3.红色和紫色.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><p>using namespace std;</p><p>int main(){<br>    int n = 0;<br>    int m = 0;<br>    while(n &lt; 1){<br>        cin&gt;&gt;n;<br>    }<br>     while(m &lt; 1){<br>        cin&gt;&gt;m;<br>    }<br>    if(n % 2 == 1 &amp;&amp; m % 2 == 1){<br>        cout&lt;&lt;”akai”;<br>    }<br>    else{<br>        cout&lt;&lt;”yukari”;<br>    }<br>    return 0;<br>}<br>疑问：<br>为什么(n % 2 == 1 &amp;&amp; m % 2 == 1)这个是对的，(n * m % 2 == 1 )这个是错的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;pic-牛客/3.红色和紫色.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;include &quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>5.标题统计</title>
    <link href="http://example.com/posts/f85195b5.html"/>
    <id>http://example.com/posts/f85195b5.html</id>
    <published>2024-10-17T14:06:56.000Z</published>
    <updated>2024-10-17T12:47:26.674Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<img src="/pic-%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%A0%87%E9%A2%98%E7%BB%9F%E8%AE%A1.png" alt="alt text"><br>代码：<br>#include <iostream><br>#include <string><br>#include<cstring><br>using namespace std;</p><p>int main(){<br>    string s;<br>    getline(cin,s); &#x2F;&#x2F;知识点1<br>    int length &#x3D; s.size();<br>    for(int i &#x3D; 0; i &lt; s.size(); i++){<br>        if(s[i] - 32 &#x3D;&#x3D; 0 || s[i] &#x3D;&#x3D; ‘\n’){<br>            length–;<br>        }<br>    }<br>    cout&lt;&lt;length;<br>    return 0;<br>}<br>官方代码：<br>#include&lt;bits&#x2F;stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int ans&#x3D;0;<br>    char c;<br>    if(cin&gt;&gt;c)ans++; &#x2F;&#x2F;cin自动去除空格换行<br>    if(cin&gt;&gt;c)ans++; &#x2F;&#x2F;cin在读不到数据时返回0<br>    if(cin&gt;&gt;c)ans++; &#x2F;&#x2F;因为题目规定标题不超过5个字符，所以可这样做<br>    if(cin&gt;&gt;c)ans++;<br>    if(cin&gt;&gt;c)ans++;<br>    cout&lt;&lt;ans;<br>}<br>知识点：<br>1.getline(cin,s)和 get(s)<br>可输入带空格，换行等符号的字符串</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;img src=&quot;/pic-%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%A0%87%E9%A2%98%E7%BB%9F%E8%AE%A1.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;br&gt;#in</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.文字处理软件</title>
    <link href="http://example.com/posts/e8344066.html"/>
    <id>http://example.com/posts/e8344066.html</id>
    <published>2024-10-17T14:06:56.000Z</published>
    <updated>2024-10-18T11:59:14.592Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<img src="/pic-%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/6.%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6.png" alt="alt text"><br>代码：<br>#include <iostream><br>#include <string><br>#include<cstring><br>using namespace std;</p><p>int amount,num;<br>string first,last;</p><p>void insertlast(){<br>    string str;<br>    cin&gt;&gt;str;<br>    last &#x3D; last.append(str);&#x2F;&#x2F;知识点1<br>    cout&lt;&lt;last&lt;&lt;endl;<br>    amount–;<br>}<br>void acquire(){<br>    int a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    if(a &gt; last.size() - 1){<br>        a &#x3D; last.size() - 1;<br>        b &#x3D; 0;<br>    }<br>    else if(a + b &gt; last.size()){<br>        b &#x3D; last.size() - a ;<br>    }<br>    string str(last,a,b); &#x2F;&#x2F;知识点3<br>    last &#x3D; str;<br>    cout&lt;&lt;last&lt;&lt;endl;<br>    amount–;<br>}<br>void insertmid(){<br>    int a;<br>    string str;<br>    cin&gt;&gt;a&gt;&gt;str;<br>    if(a &gt; last.size() - 1 ){<br>        a &#x3D; last.size() - 1;<br>    }<br>    last.insert(a,str); &#x2F;&#x2F;知识点4<br>    cout&lt;&lt;last&lt;&lt;endl;<br>    amount–;<br>}<br>void search(){<br>    string str;<br>    cin&gt;&gt;str;<br>    int a &#x3D; last.find(str);&#x2F;&#x2F;知识点5<br>    cout&lt;&lt;a&lt;&lt;endl;<br>    amount–;<br>}<br>int main(){<br>    cin&gt;&gt;amount&gt;&gt;last;<br>    while(amount !&#x3D; 0){<br>        &#x2F;&#x2F;cout&lt;&lt;”返回,输入num”&lt;&lt;endl;<br>        cin&gt;&gt;num;<br>        switch(num){<br>            case 1: insertlast();break;<br>            case 2: acquire();break;<br>            case 3: insertmid();break;<br>            case 4: search();break;<br>        }<br>    }<br>    return 0;<br>}<br>知识点：<br>1.last &#x3D; last.append(str) append()<br>作用：将括号里的字符串拼接到目标字符串的末尾<br>用法：争对string类型（c++）<br>头文件：#include <string></p><p>2.扩展：strcat(dest,src)<br>作用：strcat 函数将 src 串拼接到 dest 串之后<br>用法：争对char[]类型（c++&#x2F;c）<br>头文件：C语言：#include&lt;string.h&gt;</p><p>3.string str(last,a,b);<br>作用：建立字符串，等于，从last的第a（第一个从0开始数）个字符开始的b（包括a）个元素的字符串<br>用法：争对string类型（c++）<br>头文件：#include <string></p><p>4.last.insert(a,str);<br>作用：在第a个位置之前插入str字符串；<br>用法：争对string类型（c++）<br>头文件：#include <string></p><p>5.int a &#x3D; last.find(str);<br>作用：在目标字符串a中找字符串str的最先的位置，如果找不到输出-1<br>用法：争对string类型（c++）<br>头文件：#include <string></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;img src=&quot;/pic-%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/6.%E6%96%87%E5%AD%97%E5%A4%84%E7%90%86%E8%BD%AF%E4%BB%B6.png&quot; alt=&quot;alt te</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>7.统计单词数</title>
    <link href="http://example.com/posts/f706c1aa.html"/>
    <id>http://example.com/posts/f706c1aa.html</id>
    <published>2024-10-17T14:06:56.000Z</published>
    <updated>2024-10-19T13:56:10.407Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<img src="/pic-%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/7.%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E6%95%B0.png" alt="alt text"><br>代码：<br>#include <iostream><br>#include <cmath><br>#include <algorithm><br>using namespace std;</p><p>int main(){<br>    string intend,passage;<br>    int num &#x3D; 0,first &#x3D; 0;<br>    getline(cin,intend);<br>    getline(cin,passage);&#x2F;&#x2F;输入<br>    for(int i &#x3D; 0; i &lt; intend.size();i++){<br>        intend[i] &#x3D; tolower(intend[i]);<br>    }<br>    for(int i &#x3D; 0; i &lt; passage.size();i++){<br>        passage[i] &#x3D; tolower(passage[i]);<br>    }&#x2F;&#x2F;统一格式<br>    intend &#x3D; intend.append(“ “);      &#x2F;&#x2F;a&#x3D;’ ‘+a+’ ‘;<br>                                        b&#x3D;’ ‘+b+’ ‘;&#x2F;&#x2F;简单写法<br>    intend &#x3D; intend.insert(0,” “);<br>    passage &#x3D; passage.append(“ “);<br>    passage &#x3D; passage.insert(0,” “);<br>    first &#x3D; passage.find(intend);<br>    int z &#x3D; first;<br>    if(first &lt; 0){<br>        cout&lt;&lt;first;<br>        return 0 ;<br>    }<br>    while(z &gt;&#x3D; 0){<br>        string str(passage,z + intend.size() - 1,passage.size() - 1);<br>        z &#x3D; str.find(intend);<br>        passage &#x3D; str;<br>        num++;<br>    }<br>    cout&lt;&lt;num&lt;&lt;” “&lt;&lt;first;<br>    return 0;<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;img src=&quot;/pic-%E6%B4%9B%E8%B0%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/7.%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E6%95%B0.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>洛谷-题单-字符串入门</title>
    <link href="http://example.com/posts/c7172a2b.html"/>
    <id>http://example.com/posts/c7172a2b.html</id>
    <published>2024-10-01T14:06:56.000Z</published>
    <updated>2024-10-18T11:59:34.889Z</updated>
    
    <content type="html"><![CDATA[<p>C语言字符串函数：头文件：#include &lt;string.h&gt;<br>1.stpcpy<br>作用：复制字符串<br>用法：stpcpy(目标串变量,被复制字符串变量);<br>2.strcat<br>作用：拼接字符串<br>用法：strcat(目标串变量,被拼接字符串变量)<br>3.strchr<br>作用：<br>用法：<br>4.<br>作用：<br>用法：<br>5.<br>作用：<br>用法：</p><p>C++知识点<br>一.string类<br>作用：约等于char,是 C++用来代替 char 数组的数据结构,且是动态变化的，不用对大小进行约束</p><p>结构：是一个类，为一个顺序表，类的内部封装了char*</p><p>在使用string类时，必须包含 #include 头文件以及  using namespace std</p><p>用法：<br>一. string的构造函数的形式：<br>string str：生成空字符串</p><p>string s(str)：生成字符串为str的复制品</p><p>string s(str, strbegin,strlen)：将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</p><p>string s(cstr, char_len)：以C_string类型cstr的前char_len个字符串作为字符串s的初值</p><p>string s(num ,c)：生成num个c字符的字符串</p><p>string s(str, stridx)：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</p><p>eg:</p><pre><code>string str1;               //生成空字符串string str2(&quot;123456789&quot;);  //生成&quot;1234456789&quot;的复制品string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot;string str4(&quot;012345&quot;, 5);  //结果为&quot;01234&quot;string str5(5, &#39;1&#39;);       //结果为&quot;11111&quot;string str6(str2, 2);      //结果为&quot;3456789&quot;二. string的大小和容量：</code></pre><ol><li><p>size()和length()：返回string对象的字符个数，他们执行效果相同。</p></li><li><p>max_size()：返回string对象最多包含的字符数，超出会抛出length_error异常</p></li><li><p>capacity()：重新分配内存之前，string对象能包含的最大字符数<br>void test2()<br>{<br> string s(“1234567”);<br> cout &lt;&lt; “size&#x3D;” &lt;&lt; s.size() &lt;&lt; endl;<br> cout &lt;&lt; “length&#x3D;” &lt;&lt; s.length() &lt;&lt; endl;<br> cout &lt;&lt; “max_size&#x3D;” &lt;&lt; s.max_size() &lt;&lt; endl;<br> cout &lt;&lt; “capacity&#x3D;” &lt;&lt; s.capacity() &lt;&lt; endl;</p></li></ol><p>}<br>三. string的字符串比较：</p><ol><li><p>C ++字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。<br>在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，<br>比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小(前面减后面)<br>同时，string (“aaaa”) &lt;string(aaaaa)。    </p></li><li><p>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。<br>  他返回一个整数来表示比较结果，返回值意义如下：0：相等 1：大于 -1：小于 (A的ASCII码是65，a的ASCII码是97)<br>  void test3()<br>{<br> &#x2F;&#x2F; (A的ASCII码是65，a的ASCII码是97)<br> &#x2F;&#x2F; 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0<br> string A(“aBcd”);<br> string B(“Abcd”);<br> string C(“123456”);<br> string D(“123dfg”);</p><p> &#x2F;&#x2F; “aBcd” 和 “Abcd”比较—— a &gt; A<br> cout &lt;&lt; “A.compare(B)：” &lt;&lt; A.compare(B)&lt;&lt; endl;                          &#x2F;&#x2F; 结果：1</p><p> &#x2F;&#x2F; “cd” 和 “Abcd”比较——- c &gt; A<br> cout &lt;&lt; “A.compare(2, 3, B):” &lt;&lt;A.compare(2, 3, B)&lt;&lt; endl;                &#x2F;&#x2F; 结果：1</p><p> &#x2F;&#x2F; “cd” 和 “cd”比较<br> cout &lt;&lt; “A.compare(2, 3, B, 2, 3):” &lt;&lt; A.compare(2, 3, B, 2, 3) &lt;&lt; endl;  &#x2F;&#x2F; 结果：0</p><p> &#x2F;&#x2F; 由结果看出来：0表示下标，3表示长度<br> &#x2F;&#x2F; “123” 和 “123”比较<br> cout &lt;&lt; “C.compare(0, 3, D, 0, 3)” &lt;&lt;C.compare(0, 3, D, 0, 3) &lt;&lt; endl;    &#x2F;&#x2F; 结果：0</p></li></ol><p>}<br>四. string的插入：push_back() 和 insert()<br>void  test4()<br>{<br>    string s1;</p><pre><code>// 尾插一个字符s1.push_back(&#39;a&#39;);s1.push_back(&#39;b&#39;);s1.push_back(&#39;c&#39;);cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:abc// insert(pos,char):在制定的位置pos前插入字符chars1.insert(s1.begin(),&#39;1&#39;);cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:1abc</code></pre><p>}<br>五、string拼接字符串：append()<br>void test5()<br>{<br>    &#x2F;&#x2F; 方法一：append()<br>    string s1(“abc”);<br>    s1.append(“def”);<br>    cout&lt;&lt;”s1:”&lt;&lt;s1&lt;&lt;endl; &#x2F;&#x2F; s1:abcdef</p><pre><code>// 方法二：+ 操作符string s2 = &quot;abc&quot;;/*s2 += &quot;def&quot;;*/string s3 = &quot;def&quot;;s2 += s3.c_str();cout&lt;&lt;&quot;s2:&quot;&lt;&lt;s2&lt;&lt;endl; // s2:abcdef</code></pre><p>}<br>六、 string的遍历：借助迭代器 或者 下标法<br>void test6()<br>{<br>    string s1(“abcdef”); &#x2F;&#x2F; 调用一次构造函数</p><pre><code>// 方法一： 下标法for( int i = 0; i &lt; s1.size() ; i++ )&#123;    cout&lt;&lt;s1[i];&#125;cout&lt;&lt;endl;// 方法二：正向迭代器string::iterator iter = s1.begin();for( ; iter &lt; s1.end() ; iter++)&#123;    cout&lt;&lt;*iter;&#125;cout&lt;&lt;endl;// 方法三：反向迭代器string::reverse_iterator riter = s1.rbegin();for( ; riter &lt; s1.rend() ; riter++)&#123;    cout&lt;&lt;*riter;&#125;cout&lt;&lt;endl;</code></pre><p>}<br>七、 string的删除：erase()</p><ol><li><p>iterator erase(iterator p);&#x2F;&#x2F;删除字符串中p所指的字符</p></li><li><p>iterator erase(iterator first, iterator last);&#x2F;&#x2F;删除字符串中迭代器</p></li></ol><p>区间[first,last)上所有字符</p><ol start="3"><li>string&amp; erase(size_t pos &#x3D; 0, size_t len &#x3D; npos);&#x2F;&#x2F;删除字符串中从索引</li></ol><p>位置pos开始的len个字符</p><ol start="4"><li><p>void clear();&#x2F;&#x2F;删除字符串中所有字符<br>void test6()<br>{<br> string s1 &#x3D; “123456789”;</p><p> &#x2F;&#x2F; s1.erase(s1.begin()+1);              &#x2F;&#x2F; 结果：13456789<br> &#x2F;&#x2F; s1.erase(s1.begin()+1,s1.end()-2);   &#x2F;&#x2F; 结果：189<br> s1.erase(1,6);                       &#x2F;&#x2F; 结果：189<br> string::iterator iter &#x3D; s1.begin();<br> while( iter !&#x3D; s1.end() )<br> {<br> cout&lt;&lt;*iter;<br> *iter++;<br> }<br> cout&lt;&lt;endl;</p></li></ol><p>}<br>八、 string的字符替换：</p><ol><li>string&amp; replace(size_t pos, size_t n, const char *s);&#x2F;&#x2F;将当前字符串</li></ol><p>从pos索引开始的n个字符，替换成字符串s</p><ol start="2"><li><p>string&amp; replace(size_t pos, size_t n, size_t n1, char c); &#x2F;&#x2F;将当前字符串从pos索引开始的n个字符，替换成n1个字符c</p></li><li><p>string&amp; replace(iterator i1, iterator i2, const char* s);&#x2F;&#x2F;将当前字符串[i1,i2)区间中的字符串替换为字符串s<br>void test7()<br>{<br> string s1(“hello,world!”);</p><p> cout&lt;&lt;s1.size()&lt;&lt;endl;                     &#x2F;&#x2F; 结果：12<br> s1.replace(s1.size()-1,1,1,’.’);           &#x2F;&#x2F; 结果：hello,world.</p><p> &#x2F;&#x2F; 这里的6表示下标  5表示长度<br> s1.replace(6,5,”girl”);                    &#x2F;&#x2F; 结果：hello,girl.<br> &#x2F;&#x2F; s1.begin(),s1.begin()+5 是左闭右开区间<br> s1.replace(s1.begin(),s1.begin()+5,”boy”); &#x2F;&#x2F; 结果：boy,girl.<br> cout&lt;&lt;s1&lt;&lt;endl;</p></li></ol><p>}<br>九、 string的大小写转换：tolower() 大转小 和toupper()函数 或者 STL中的transform算法<br>法一：使用C语言之前的方法，使用函数，进行转换<br>#include <iostream><br>#include <string><br>using namespace std;</p><p>int main()<br>{<br>    string s &#x3D; “ABCDEFG”;</p><pre><code>for( int i = 0; i &lt; s.size(); i++ )&#123;    s[i] = tolower(s[i]);&#125;cout&lt;&lt;s&lt;&lt;endl;return 0;</code></pre><p>}<br>法二：通过STL的transform算法配合的toupper和tolower来实现该功能<br>#include <iostream><br>#include <algorithm><br>#include <string></p><p>using namespace std;</p><p>int main()<br>{<br>    string s &#x3D; “ABCDEFG”;<br>    string result;</p><pre><code>transform(s.begin(),s.end(),s.begin(),::tolower);cout&lt;&lt;s&lt;&lt;endl;return 0;</code></pre><p>}<br>十、 string的查找：find</p><ol><li>size_t find (constchar* s, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，</p><pre><code>-1表示查找不到子串</code></pre><ol start="2"><li>size_t find (charc, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，</p><pre><code>-1表示查找不到字符</code></pre><ol start="3"><li>size_t rfind (constchar* s, size_t pos &#x3D; npos) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，</p><pre><code>-1表示查找不到子串</code></pre><ol start="4"><li>size_t rfind (charc, size_t pos &#x3D; npos) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</p><ol start="5"><li>size_tfind_first_of (const char* s, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><ol start="6"><li>size_tfind_first_not_of (const char* s, size_t pos &#x3D; 0) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><ol start="7"><li>size_t find_last_of(const char* s, size_t pos &#x3D; npos) const;</li></ol><p>  &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p><ol start="8"><li>size_tfind_last_not_of (const char* s, size_t pos &#x3D; npos) const;</li></ol><p> &#x2F;&#x2F;在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串<br> void test8()<br>{<br>    string s(“dog bird chicken bird cat”);</p><pre><code>//字符串查找-----找到后返回首字母在字符串中的下标// 1. 查找一个字符串cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl;        // 结果是：9// 2. 从下标为6开始找字符&#39;i&#39;，返回找到的第一个i的下标cout &lt;&lt; s.find(&#39;i&#39;,6) &lt;&lt; endl;            // 结果是：11// 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl;       // 结果是：9// 4. 从字符串的末尾开始查找字符cout &lt;&lt; s.rfind(&#39;i&#39;) &lt;&lt; endl;             // 结果是：18-------因为是从末尾开始查找，所以返回第一次找到的字符// 5. 在该字符串中查找第一个属于字符串s的字符cout &lt;&lt; s.find_first_of(&quot;13br98&quot;) &lt;&lt; endl;  // 结果是：4---b// 6. 在该字符串中查找第一个不属于字符串s的字符------先匹配dog，然后bird匹配不到，所以打印4cout &lt;&lt; s.find_first_not_of(&quot;hello dog 2006&quot;) &lt;&lt; endl; // 结果是：4cout &lt;&lt; s.find_first_not_of(&quot;dog bird 2006&quot;) &lt;&lt; endl;  // 结果是：9// 7. 在该字符串最后中查找第一个属于字符串s的字符cout &lt;&lt; s.find_last_of(&quot;13r98&quot;) &lt;&lt; endl;               // 结果是：19// 8. 在该字符串最后中查找第一个不属于字符串s的字符------先匹配t--a---c，然后空格匹配不到，所以打印21cout &lt;&lt; s.find_last_not_of(&quot;teac&quot;) &lt;&lt; endl;            // 结果是：21</code></pre><p>}<br>十一、 string的排序：sort(s.begin(),s.end())<br>#include <iostream><br>#include <algorithm><br>#include <string><br>using namespace std;</p><p>void test9()<br>{<br>    string s &#x3D; “cdefba”;<br>    sort(s.begin(),s.end());<br>    cout&lt;&lt;”s:”&lt;&lt;s&lt;&lt;endl;     &#x2F;&#x2F; 结果：abcdef<br>}<br>十二、 string的分割&#x2F;截取字符串：strtok() &amp; substr()<br>void test10()<br>{<br>    char str[] &#x3D; “I,am,a,student; hello world!”;</p><pre><code>const char *split = &quot;,; !&quot;;char *p2 = strtok(str,split);while( p2 != NULL )&#123;    cout&lt;&lt;p2&lt;&lt;endl;    p2 = strtok(NULL,split);&#125;</code></pre><p>}<br>void test11()<br>{<br>    string s1(“0123456789”);<br>    string s2 &#x3D; s1.substr(2,5); &#x2F;&#x2F; 结果：23456—–参数5表示：截取的字符串的长度<br>    cout&lt;&lt;s2&lt;&lt;endl;<br>}</p><p>二.相应头文件<br>1.using namespace std; :<br>引入命名空间 std 中的所有符号，这样在代码中就可以直接使用标准库中的函数、类、对象等，而不需要在每个标准库的成员前面加上 std:: 前缀<br>2.#include<cstring><br>提供了一些用于处理字符串的函数，比如字符串复制、连接、比较等。这个头文件通常用于 C 风格的字符串操作。<br>3.#include<iostream><br>它提供了 C++ 标准输入输出流的支持。包含这个头文件可以让你在程序中使用标准的输入输出流，比如 std::cout 和 std::cin<br>4.#include<cstdio><br>提供了一些函数来进行输入和输出操作，比如 printf 和 scanf。这个头文件通常用于 C 风格的输入输出操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C语言字符串函数：头文件：#include &amp;lt;string.h&amp;gt;&lt;br&gt;1.stpcpy&lt;br&gt;作用：复制字符串&lt;br&gt;用法：stpcpy(目标串变量,被复制字符串变量);&lt;br&gt;2.strcat&lt;br&gt;作用：拼接字符串&lt;br&gt;用法：strcat(目标串变量,被</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>洛谷-题单-字符串入门-代码</title>
    <link href="http://example.com/posts/4cd84e39.html"/>
    <id>http://example.com/posts/4cd84e39.html</id>
    <published>2024-10-01T14:06:56.000Z</published>
    <updated>2024-10-18T11:59:20.136Z</updated>
    
    <content type="html"><![CDATA[<p>题目：自动修正<br><img src="/pic/%E8%87%AA%E5%8A%A8%E4%BF%AE%E6%AD%A3.png" alt="alt text"><br>#include <iostream><br>#include <string><br>using namespace std;</p><p>int main(){<br>    string s;<br>    cin&gt;&gt;s;<br>    for(int i &#x3D; 0; i &lt; s.length();i++){<br>        s[i] &#x3D; toupper(s[i]);<br>    }<br>    cout&lt;&lt;s;<br>    return 0;<br>}<br>错误原因：<br>1.不会转大小写<br>A 的ASCII为 66 （小） a的ASCII为98 （大）差32<br>把小写转换成大写就是：<br>if(a[i]&gt;&#x3D;’a’ &amp;&amp; a[i]&lt;&#x3D;’z’)<br>{<br>    a[i]&#x3D;a[i]-‘a’+’A’;  &#x2F;&#x2F;a[i]&#x3D;a[i]- (‘a’ - A)<br>}<br>把大写转换成小写就是：</p><p>if(a[i]&gt;&#x3D;’A’ &amp;&amp; a[i]&lt;&#x3D;’Z’)<br>{<br>    a[i]&#x3D;a[i]-‘A’+’a’;<br>}</p><p>题目:小书童-凯撒密码<br><img src="/pic/%E5%B0%8F%E4%B9%A6%E7%AB%A5%E2%80%94%E2%80%94%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81.png" alt="alt text"><br>c++<br>最终版本：<br>#include <iostream><br>#include <string><br>using namespace std;</p><p>int main(){<br>    string s;<br>    int n;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    if(n &gt;0&amp;&amp;n &lt;27){<br>        for(int i &#x3D; 0; i &lt; s.length();i++){<br>            if (islower(s[i])) {    &#x2F;&#x2F;islower(s[i]) 是一个函数调用，用于检查字符 s[i] 是否为小写字母<br>                s[i] &#x3D; ‘a’ + (s[i] - ‘a’ + n) % 26; &#x2F;&#x2F;string 约等于 char[],所以可用数组的方法<br>            }<br>        }<br>    }<br>    cout&lt;&lt;s;<br>    return 0;<br>}</p><p>c语言<br>#include &lt;stdio.h&gt;</p><p>int main(){<br>    int n;<br>    char str[100];<br>    scanf(“%d%s”,&amp;n,str);<br>    for(int i &#x3D; 0; str[i] !&#x3D; ‘\0’;i++){<br>        str[i] &#x3D; ‘a’ + (str[i] - ‘a’ + n) % 26; &#x2F;&#x2F; 也可写为 putchar((in[j]-‘a’+n)%26+’a’);<br>    }<br>    printf(“%s”,str); &#x2F;&#x2F;使没有显式使用第二个循环来输出字符串，但由于 C 语言的特性，C 字符串以 null 结尾（即以 \0 结尾），printf(“%s”, str); 会一直输出字符直到遇到 null 终止符为止。<br>    return 0;<br>}</p><p>错误原因：<br>1.没有想到z跳完之后要转到a的情况<br>2.没有想到检测小写，而是直接转小写，不符合题意<br>3.(str[i] - ‘a’ + n)写成(‘a’ - str[i]  + n) 小- 大导致错误<br>重点：<br>1.s[i] &#x3D; ‘a’ + (s[i] - ‘a’ + n) % 26;<br>这行代码是用来实现对小写字母进行向后移动 n 位的操作。让我们解释一下这行代码的具体功能：<br>s[i] - ‘a’：这部分计算了当前字符 s[i] 相对于小写字母表中的字母 ‘a’ 的偏移量。<br>(s[i] - ‘a’ + n)：这一部分将偏移量加上移动的位数 n，以实现向后移动的效果。<br>(s[i] - ‘a’ + n) % 26：由于小写字母表只有 26 个字母，因此这一部分确保结果在 0 到 25 之间，以便在字母表上循环移动。<br>‘a’ + (s[i] - ‘a’ + n) % 26：最后，将结果映射回小写字母表，得到移动后的字符。<br>2.putchar()<br>putchar()是一个 C 语言标准库函数，用于将一个字符输出到标准输出流（通常是控制台）<br>eg:putchar(66) &#x3D; printf(“A”)</p><p>必学方法：确保结果在 0 到 25 之间，利用 % 26得到!!!!!!</p><p>3.题目 笨小猴<br><img src="/pic/%E7%AC%A8%E5%B0%8F%E7%8C%B4.png" alt="alt text"><br>代码：<br>正确版本：<br>#include <iostream><br>#include <string><br>#include <cmath>  &#x2F;&#x2F;提供了对基本数学运算和函数的支持</p><p>using namespace std;</p><p>&#x2F;&#x2F;知识点2 素数的判断<br>bool isPrime(int num) { &#x2F;&#x2F;bool表示布尔值的返回类型<br>    if (num &lt;&#x3D; 1) return false;<br>    for (int i &#x3D; 2; i &lt;&#x3D; sqrt(num); i++) {  &#x2F;&#x2F;sqrt(num)开方，即使根号2小于2，但是仍然把根号2，取到2来看待<br>        if (num % i &#x3D;&#x3D; 0) return false;<br>    }<br>    return true;<br>}</p><p>int main() {<br>    string str;<br>    cin &gt;&gt; str;<br>    int n[26] &#x3D; {0};</p><pre><code>// 统计每个字母出现的次数for (char c : str) &#123;    //知识点1 增强型for循环    n[c - &#39;a&#39;]++;&#125;int maxn = 0, minn = 100;  // 初始化minn为一个较大值// 找到最大和最小的非零频率for (int i = 0; i &lt; 26; i++) &#123;    if (n[i] &gt; 0) &#123;        if (n[i] &gt; maxn) maxn = n[i];        if (n[i] &lt; minn) minn = n[i];    &#125;&#125;int z = maxn - minn;// 根据z的值判断输出if (isPrime(z)) &#123;    cout &lt;&lt; &quot;Lucky Word&quot; &lt;&lt; endl &lt;&lt; z;&#125; else &#123;    cout &lt;&lt; &quot;No Answer&quot; &lt;&lt; endl &lt;&lt; 0;&#125;return 0;</code></pre><p>}</p><p>知识点：<br>1.增强型for循环（c++）<br>    1&gt;遍历字符串 string s;<br>        for( int i &#x3D; 0; i &lt; s.length(); i++)：通常写法<br>        for (char c : s)：复制一个s字符串再进行遍历操作（慢）<br>        for (char&amp; c : s)：直接引用原字符串进行遍历操作（快）<br>    2&gt;遍历数组 int a[6] &#x3D; { 3,2,1,4,9,0 };<br>        for (int i : a)<br>        for (int &amp;i : a) </p><p>2.素数的判断<br>bool isPrime(int num) {<br>    if (num &lt;&#x3D; 1) return false;<br>    for (int i &#x3D; 2; i &lt;&#x3D; sqrt(num); i++) {<br>        if (num % i &#x3D;&#x3D; 0) return false;<br>    }<br>    return true;<br>}</p><p>错误版本： 错误原因未知<br>#include <iostream><br>#include <string><br>#include<algorithm><br>#include <cmath></p><p>using namespace std;</p><p>int main(){<br>    string str;<br>    cin&gt;&gt;str;<br>    int n[25] &#x3D; {0};<br>    int z;<br>    for(int i &#x3D; 0; i &lt; str.size(); i++){<br>        n[str[i] - ‘a’]++;<br>    }<br>    sort(n, n + 26);<br>    &#x2F;*for(int i &#x3D; 0; i &lt; 26; i++){<br>        cout&lt;&lt;n[i];<br>    }*&#x2F;<br>    for(int i &#x3D; 0; i &lt; 26; i++){<br>        if(n[i] &gt; 0){<br>            z &#x3D; n[25] - n[i];<br>            break;<br>        }<br>    }<br>    if(z &#x3D;&#x3D; 2 || z&#x3D;&#x3D;3){<br>        cout&lt;&lt;”Lucky Word”;<br>    }<br>    else if(z &#x3D;&#x3D; 0||z &#x3D;&#x3D; 1){<br>        cout&lt;&lt;”No Answer”;<br>    }<br>    else{<br>        int c &#x3D; 0;<br>        for(int i &#x3D; 2; i &lt;&#x3D; sqrt(z);i++){<br>            if(z % i &#x3D;&#x3D; 0){<br>                c &#x3D; 1;<br>                break;<br>            }<br>        }<br>        if(c &#x3D;&#x3D; 1) cout&lt;&lt;”No Answer”;<br>        else cout&lt;&lt;”Lucky Word”;<br>    }<br>    cout&lt;&lt;endl&lt;&lt;z;<br>    return 0;<br>}</p><p>题目：口算练习题<br><img src="/pic/%E5%8F%A3%E7%AE%97%E7%BB%83%E4%B9%A0%E9%A2%98.png" alt="alt text"></p><p>代码：<br>#include <iostream><br>#include <string><br>#include<algorithm><br>#include <cmath><br>#include<cstring><br>using namespace std;</p><p>int main(){<br>    int i;<br>    cin&gt;&gt;i; &#x2F;&#x2F;input amount of data<br>    int x,y; &#x2F;&#x2F;two caozuoshu<br>    char z,f; &#x2F;&#x2F;z is the last sign ,f is the new sign or data<br>    while(i&gt;0){<br>        i–;<br>        char s1[100];<br>        char s[100];<br>        scanf(“%s”,&amp;s1);<br>        if(s1[0] &#x3D;&#x3D; ‘a’||s1[0] &#x3D;&#x3D; ‘b’||s1[0] &#x3D;&#x3D; ‘c’){<br>            z &#x3D; s1[0];<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>        }<br>        else{<br>            x &#x3D; atoi(s1);   &#x2F;&#x2F;知识点1<br>            scanf(“%d”,&amp;y);<br>        }<br>        if(z &#x3D;&#x3D; ‘a’){<br>            sprintf(s,”%d+%d&#x3D;%d”,x,y,x+y);<br>        }<br>        else if(z &#x3D;&#x3D; ‘b’){<br>            sprintf(s,”%d-%d&#x3D;%d”,x,y,x-y);<br>        }<br>        else if(z &#x3D;&#x3D; ‘c’){<br>            sprintf(s,”%d*%d&#x3D;%d”,x,y,x*y);<br>        }<br>        &#x2F;&#x2F;cout&lt;&lt;endl&lt;&lt;strlen(s);<br>        printf(“%s\n%d\n”,s,strlen(s));<br>    }<br>    return 0;<br>}<br>知识点：<br>1.字符转数字<br> 1&gt;stoi()<br>    将字符串转换为int型<br>    针对于string类型的(char也行)。stoi函数是C++11引入的，因此只有在C++11及以上的版本中才能使用该函数<br>    同理stol()、stof()、stod(),分别将字符串类型转换成long long、float、double类型</p><p> 2&gt;atoi()<br>    toi()函数是C语言中的一个函数，主要用于将字符串转换为整数。针对于字符数组,类似的还有atol()、atof()、atod()</p><p> 3&gt;利用ASCII<br>    #include<iostream><br>    #include<cstring><br>    using namespace std;<br>    char ch[]&#x3D;{‘1’,’2’,’3’,’4’,’5’};<br>    int main(){<br>        for(int i&#x3D;0;i&lt;strlen(ch);i++){<br>            cout&lt;&lt;ch[i]-‘0’&lt;&lt;” “; &#x2F;&#x2F;重点<br>        }<br>        return 0;<br>    }</p><p> 4&gt;stringstream<br>    stringstream是C++中的一个类，可以用来对字符串进行输入输出操作<br>    它是基于字符串的流，可以用来将字符串转换为其他类型的数据，以及将其他类型的数据转换为字符串。stringstream类的头文件是<sstream>，我们需要包含这个头文件才能使用stringstream类。<br>    eg:<br>    #include<iostream><br>    #include<sstream><br>    #include<cstring><br>    #include<typeinfo></p><pre><code>using namespace std;int main()&#123;stringstream ss;string s=&quot;12345&quot;;int num;ss&lt;&lt;s;//将字符串读入字符串流 ss&gt;&gt;num;//从字符串流中读取数据转换为整数cout&lt;&lt;typeid(num).name()&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;return 0; &#125;</code></pre><p>2.数字转为字符串<br>    1&gt;利用ASCII<br>    字符转数字可以-‘0’，数字转字符那么就可以+’0’<br>    cout&lt;&lt;nums[i]+’0’&lt;&lt;” “;</p><pre><code>2&gt;to_string()用于将不同类型的数据转换为字符串可以将int、float、double、long long等类型转换为string类型。需要包含头文件#include&lt;cstring&gt;（c++）3&gt;itoa()toa函数用于将整数转换为字符串。类似的还有ltoa、ftoa、dtoa分别将long long、float、double转换为字符串类型。针对于字符数组4&gt;stringstream</code></pre><p>#include<iostream><br>#include<sstream><br>#include<cstring><br>#include<typeinfo></p><p>using namespace std;<br>int main(){<br>    stringstream ss;<br>    string s&#x3D;”12345”;<br>    int num&#x3D;54321;<br>    ss&lt;&lt;num;&#x2F;&#x2F;将int类型的数据写入字符串流中<br>    s&#x3D;ss.str();&#x2F;&#x2F;将字符串流中的数据转换为string类型<br>    cout&lt;&lt;typeid(s).name()&lt;&lt;” “&lt;&lt;num&lt;&lt;endl;<br>    return 0;<br>}</p><p>3.sscanf()和sprintf()<br>实现数据与字符串之间的转换</p><p>sscanf()作用：<br>（1）根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。<br>（2）取指定长度的字符串<br>（3）取到指定字符为止的字符串<br>（4）取仅包含指定字符集的字符串<br>（5）取到指定字符集为止的字符串<br>sscanf可以支持格式字符%[]：<br>(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字 %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母<br>(2)^: 表示不取，如：%[^1]表示读取除’1’以外的所有字符 %[^&#x2F;]表示除&#x2F;以外的所有字符<br>(3),: 范围可以用”,”相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母<br>(4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %<a href="%E6%B3%A8%E6%84%8F%5E%E5%90%8E%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC%EF%BC%81">^ </a></p><p>sprintf()作用：<br> 1     char str[256] &#x3D; { 0 };<br> 2     int data &#x3D; 1024;<br> 3     &#x2F;&#x2F;将data转换为字符串<br> 4     sprintf(str,”%d”,data);<br> 5     &#x2F;&#x2F;获取data的十六进制<br> 6     sprintf(str,”0x%X”,data);<br> 7     &#x2F;&#x2F;获取data的八进制<br> 8     sprintf(str,”0%o”,data);<br> 9     const char *s1 &#x3D; “Hello”;<br>10     const char *s2 &#x3D; “World”;<br>11     &#x2F;&#x2F;连接字符串s1和s2<br>12     sprintf(str,”%s %s”,s1,s2);</p><p>4.strlen(s)</p><p>易错点：<br>char ss[100],并不意味着ss的长度就是100，而是界限为100，用strlen(s)来求取长度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：自动修正&lt;br&gt;&lt;img src=&quot;/pic/%E8%87%AA%E5%8A%A8%E4%BF%AE%E6%AD%A3.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;#include &lt;iostream&gt;&lt;br&gt;#include &lt;string&gt;&lt;br&gt;using </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2.删除公共字符</title>
    <link href="http://example.com/posts/22b2968b.html"/>
    <id>http://example.com/posts/22b2968b.html</id>
    <published>2024-10-01T14:06:56.000Z</published>
    <updated>2024-10-19T13:56:10.417Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="/pic-%E7%89%9B%E5%AE%A2/2.%E5%88%A0%E9%99%A4%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6.png" alt="alt text"><br>代码：<br>#include <iostream><br>#include <string><br>using namespace std;<br>&#x2F;&#x2F;没有要求大小写 所以没做出说明<br>int main(){<br>    string str1,str2;<br>    getline(cin,str1);<br>    cin&gt;&gt;str2;<br>    for(int i &#x3D; 0; i &lt; str2.size();i++){<br>        int pos &#x3D; str1.find(str2[i]);<br>        while(pos &gt;&#x3D; 0){<br>            str1 &#x3D; str1.erase(pos,1); &#x2F;&#x2F;知识点1<br>            pos &#x3D; str1.find(str2[i]);<br>        }<br>    }<br>    cout&lt;&lt;str1;<br>    return 0;<br>}<br>知识点：<br>1.str1.erase(pos,1);<br>作用：删除string字符串str1里pos位置（从0开始数），的n个字符（这里N直接用的1）（包括pos位置）<br>头文件：#include <string></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;/pic-%E7%89%9B%E5%AE%A2/2.%E5%88%A0%E9%99%A4%E5%85%AC%E5%85%B1%E5%AD%97%E7%AC%A6.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;br&gt;#include</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1.差值</title>
    <link href="http://example.com/posts/ac608bef.html"/>
    <id>http://example.com/posts/ac608bef.html</id>
    <published>2024-10-01T14:06:56.000Z</published>
    <updated>2024-10-18T13:56:05.432Z</updated>
    
    <content type="html"><![CDATA[<p>题目：D:\hexo\heo\source_posts\练习题\牛客\pic-牛客\1.差值.png<br>代码：<br>#include <iostream><br>#include <cmath><br>#include <algorithm><br>using namespace std;</p><p>int main(){<br>    int n;<br>    int c &#x3D; 1000000;<br>    cin&gt;&gt;n; &#x2F;&#x2F;输入战士数量<br>    int zl[n - 1];<br>    for(int i &#x3D; 0; i &lt; n; i++){<br>        cin&gt;&gt;zl[i];<br>    }    &#x2F;&#x2F;输入战力<br>    sort(zl, zl + n); &#x2F;&#x2F;知识点1<br>    for(int i &#x3D; 0; i &lt; n - 1; i++){<br>        c &#x3D; abs(zl[i] - zl[i + 1]) &lt; c ? abs(zl[i] - zl[i + 1]) : c;    &#x2F;&#x2F;知识点2<br>        if(c &#x3D;&#x3D; 0) break;<br>    }<br>    cout&lt;&lt;c;<br>    return 0;<br>}</p><p>知识点：<br>1.排序c++ sort()<br>用法：sort(begin, end, cmp)<br>    begin为指向待sort()的数组的第一个元素的指针<br>    end为指向待sort()的数组的最后一个元素的下一个位置的指针<br>    cmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序。如果我们想从大到小排序可以将cmp参数写为greater<int>()就是对int数组进行排序，当然&lt;&gt;中我们也可以写double、long、float等等<br>    eg：sort(num,num+10,greater<int>());&#x2F;&#x2F;大到小<br>        sort(zl, zl + n);一般情况，数组大小为多少就加多少，比如zl[5],则sort(zl,zl + 5)<br>头文件：#include <algorithm></p><p>2.绝对值<br>C++中不同的数据类型需要使用不同的绝对值函数：<br>对于整型(int)，使用abs()函数。<br>对于复数类型(complex)，使用cabs()函数来获取复数的模。<br>对于双精度浮点型(double)，使用fabs()函数。<br>对于长整型(long)，使用labs()函数。<br>头文件：C++ #include <cmath>    C #include&lt;math.h&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：D:&#92;hexo&#92;heo&#92;source_posts&#92;练习题&#92;牛客&#92;pic-牛客&#92;1.差值.png&lt;br&gt;代码：&lt;br&gt;#include &lt;iostream&gt;&lt;br&gt;#include &lt;cmath&gt;&lt;br&gt;#include &lt;algorithm&gt;&lt;br&gt;using nam</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeeCode-02-跳跃游戏2</title>
    <link href="http://example.com/posts/1ce411cd.html"/>
    <id>http://example.com/posts/1ce411cd.html</id>
    <published>2024-09-26T14:06:56.000Z</published>
    <updated>2024-10-16T11:50:41.901Z</updated>
    
    <content type="html"><![CDATA[<p>int jump(int* nums, int numsSize) {<br>    &#x2F;*<br>    思路：<br>    1.都是从0开始，所以maxlength &#x3D; 0，每跳跃一次，遍历从index &#x3D; 0到index &#x3D; nums[i]，即这一次所能跳跃最大距离的所有的元素，判断跳跃这一 次所到达的最远距离，更新maxlength,以此类推，直至maxlength &gt;&#x3D; numsSize - 1<br>    *&#x2F;<br>    int maxlength &#x3D; nums[0];<br>    int amount &#x3D; 0;</p><pre><code>if(numsSize == 1)&#123;    return amount;&#125;if (maxlength  &gt;= numsSize - 1)&#123;        return amount + 1;    &#125;/*for(int i = 0; i &lt; numsSize; i++)&#123;    for(int j = i + 1; j &lt;= i + nums[i]; j++)&#123;        if(j == numsSize - 1)&#123;            return amount + 1;        &#125;        maxlength = maxlength &gt; nums[j] + j ? maxlength : nums[j] + j;    &#125;    amount = amount + 2;        if (maxlength  &gt;= numsSize - 1)&#123;        return amount;    &#125;    i = maxlength - 1;&#125;return amount;*/int i = 0;while(maxlength  &lt; numsSize - 1)&#123;     for(int j = i + 1; j &lt;= i + nums[i]; j++)&#123;        if(j == numsSize - 1)&#123;            return amount + 1;        &#125;        maxlength = maxlength &gt; nums[j] + j ? maxlength : nums[j] + j;    &#125;    amount = amount + 2;    i = maxlength;&#125;return amount;</code></pre><p>}</p><p>int jump(int* nums, int numsSize) {<br>    int maxlength &#x3D; nums[0];<br>    long amount &#x3D; 0; &#x2F;&#x2F; 将 amount 的类型改为 long</p><pre><code>if(numsSize == 1) &#123;    return amount;&#125;int i = 0;while (maxlength &lt;= numsSize - 1) &#123;    for (int j = i + 1; j &lt;= i + nums[i]; j++) &#123;        if (j == numsSize - 1) &#123;            return amount + 1;        &#125;        maxlength = maxlength &gt; nums[j] + j ? maxlength : nums[j] + j;        if (maxlength &gt;= numsSize - 1) &#123;            return amount + 2;        &#125;    &#125;    amount = amount + 2;    i = maxlength;&#125;return amount;</code></pre><p>}</p><p>从当前元素开始，遍历该元素值范围内能遍历的所有元素，判断选择哪个元素实现下一步走的最远<br>每遍历一个，计算一次选择该元素能到达的最远距离（下标加元素值）<br>eg:{2 3 1 1 4 6 2 1}<br>从2的下一个元素3开始遍历，选择3时，最远到达1 + 3 &#x3D; 4，选择1时，最远能到达2 + 1 &#x3D; 3，最远到达1，遍历结束，以4作为下一次遍历的开始<br>从4的下一个元素6开始遍历，选择6时，最远能到达5 + 6 &#x3D; 11，选择2时……  !!!不足点 已经达到结束条件，还要继续循环</p><p>int max(int a, int b) {<br>    return a &gt; b ? a : b;<br>}<br>int jump(int* nums, int numsSize) {<br>    int maxReach &#x3D; 0; &#x2F;&#x2F; 当前位置能到达的最远距离<br>    int steps &#x3D; 0; &#x2F;&#x2F; 跳跃次数<br>    int end &#x3D; 0; &#x2F;&#x2F; 当前跳跃范围的边界 上一次跳跃的的终点 第一次跳跃上一次的终点即为0</p><pre><code>for (int i = 0; i &lt; numsSize - 1; i++) &#123;    maxReach = max(maxReach, i + nums[i]);// 更新当前位置能到达的最远距离    if (i == end) &#123; // 如果到达当前跳跃范围的边界        end = maxReach; // 更新下一次跳跃的边界为当前位置能到达的最远距离        steps++; // 增加跳跃次数    &#125;&#125;return steps;</code></pre><p>}<br>eg:{2 3 1 1 4 6 2 1}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;int jump(int* nums, int numsSize) {&lt;br&gt;    &amp;#x2F;*&lt;br&gt;    思路：&lt;br&gt;    1.都是从0开始，所以maxlength &amp;#x3D; 0，每跳跃一次，遍历从index &amp;#x3D; 0到index &amp;#x3D; n</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeeCode-02-跳跃游戏1</title>
    <link href="http://example.com/posts/871adf45.html"/>
    <id>http://example.com/posts/871adf45.html</id>
    <published>2024-09-26T14:06:56.000Z</published>
    <updated>2024-10-16T11:50:59.406Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述：<br>解题：<br>法一：超越时间限制<br>bool canJump(int* nums, int numsSize) {<br>    &#x2F;*<br>    题目理解：<br>    目的：从nums[0]跳到nums[numsSize - 1] 约束：跳跃长度jumplength &lt;&#x3D; nums[pos] pos:当前数组元素下标<br>    目标：如果可以达到目的 跳跃次数 越少越好 否则输出false<br>    特殊点：<br>    1.nums[pos] &#x3D; 0 &amp;&amp; pos &lt; numsSize - 1<br>    2.不满足跳到最后的条件：<br>        1&gt; 总会到达跳跃长度为0的下标<br>    思路：<br>    1.跳过nums[pos] &#x3D; 0 &amp;&amp; pos &lt; numsSize - 1的数组元素<br>    2.减少跳跃次数</p><pre><code>思路2：判断如何从nums[0]跳到跳跃长度为0的下标，能找到输出false,否则输出true1.遍历数组，找到nums[pos] = 0的pos思路3：只要能找到一条跳到nums[numsSize - 1]的路，能找到输出true,否则输出false1.pos = 0 从nums[pos]开始，每次跳跃nums[pos]，2.如果nums[pos] = 0 回到上一个位置space    if nums[space] &gt;= 2 则 pos = pos + nums[pos] - 1,否则继续退到上一个位置3.如果pos + nums[pos] &gt;= numsSize - 1 返回true*/if(nums[0] == 0 &amp;&amp; numsSize != 1)&#123;    return false;&#125;else if(nums[0] == 0 &amp;&amp; numsSize == 1)&#123;    return true;&#125;int pos = 0;int amount = 0;while(pos &lt;= numsSize - 1 &amp;&amp; pos &gt;= 0)&#123;    int space = nums[pos];  //  记录上一次走的步长    pos = pos + nums[pos];    amount++;    if(pos &lt; numsSize - 1 &amp;&amp; nums[pos] == 0 )&#123;        if(space &gt; 1 &amp;&amp; amount &gt; 0)&#123;            pos = pos - space - 1;        &#125;        else&#123;            if(amount &gt; 0)&#123;                pos = pos - 1;                amount--;            &#125;            for(int i = amount; i &gt; 0; i--)&#123;                pos = pos - nums[i];                if(pos &gt;= 0 &amp;&amp; nums[pos] &gt; 1)&#123;                    pos = pos + nums[pos] - 1;                &#125;                else if (pos = 0)&#123;                    return false;                &#125;            &#125;        &#125;    &#125;&#125;if(pos &gt;= numsSize - 1)&#123;    return true;&#125;else&#123;    return false;&#125;</code></pre><p>}<br>法二：<br>bool canJump(int* nums, int numsSize) {<br>    &#x2F;*思路：<br>        目的：跳到最后一个元素numsSize - 1，只要能跳跃的最大长度大于等于numsSize - 1就能到达<br>    *&#x2F;<br>    if(numsSize &#x3D;&#x3D; 1){<br>        return  true;<br>    }<br>    int reachmax &#x3D; 0;<br>    for(int i &#x3D; 0; i &lt; numsSize - 1; i++){<br>        if(nums[i] &#x3D;&#x3D; 0 &amp;&amp; reachmax &lt;&#x3D; i){<br>            return false;<br>        }<br>        reachmax &#x3D;  reachmax &gt; i + nums[i] ? reachmax : i + nums[i];<br>        if(reachmax &gt;&#x3D; numsSize - 1){<br>            return true;<br>        }<br>    }<br>    return false;<br>}<br>体会：<br>利用贪心算法寻找局部最优解<br>具体做法：每走一步就找寻一次最优解，直至找到最后<br>例如，在该问题中，走到index 0，更新一次能够走的最大距离，继续顺序走index 2，判断在index 2能走的最大距离，以此类推</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目描述：&lt;br&gt;解题：&lt;br&gt;法一：超越时间限制&lt;br&gt;bool canJump(int* nums, int numsSize) {&lt;br&gt;    &amp;#x2F;*&lt;br&gt;    题目理解：&lt;br&gt;    目的：从nums[0]跳到nums[numsSize - 1] 约</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法-01-贪心算法1-Djikstra算法</title>
    <link href="http://example.com/posts/90b623e1.html"/>
    <id>http://example.com/posts/90b623e1.html</id>
    <published>2024-09-22T14:06:56.000Z</published>
    <updated>2024-09-28T14:10:36.208Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法:寻找局部最优解<br>大概有两种方法：Djikstra算法（迪杰斯特拉算法） 最小生成树Prim算法<br>Djikstra算法 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;贪心算法:寻找局部最优解&lt;br&gt;大概有两种方法：Djikstra算法（迪杰斯特拉算法） 最小生成树Prim算法&lt;br&gt;Djikstra算法 &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeeCode 01-坐上公交的最晚时间</title>
    <link href="http://example.com/posts/828b5000.html"/>
    <id>http://example.com/posts/828b5000.html</id>
    <published>2024-09-22T14:06:56.000Z</published>
    <updated>2024-09-28T14:07:54.493Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述：给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p><p>给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。</p><p>每位乘客都会排队搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y &lt;&#x3D; x  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。</p><p>返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。</p><p>注意：数组 buses 和 passengers 不一定是有序的。</p><p>示例：<br>示例 1：</p><p>输入：buses &#x3D; [10,20], passengers &#x3D; [2,17,18,19], capacity &#x3D; 2<br>输出：16<br>解释：<br>第 1 辆公交车载着第 1 位乘客。<br>第 2 辆公交车载着你和第 2 位乘客。<br>注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。<br>示例 2：</p><p>输入：buses &#x3D; [20,30,10], passengers &#x3D; [19,13,26,4,25,11,21], capacity &#x3D; 2<br>输出：20<br>解释：<br>第 1 辆公交车载着第 4 位乘客。<br>第 2 辆公交车载着第 6 位和第 2 位乘客。<br>第 3 辆公交车载着第 1 位乘客和你。</p><p>提示：</p><p>n &#x3D;&#x3D; buses.length<br>m &#x3D;&#x3D; passengers.length<br>1 &lt;&#x3D; n, m, capacity &lt;&#x3D; 105<br>2 &lt;&#x3D; buses[i], passengers[i] &lt;&#x3D; 109<br>buses 中的元素 互不相同 。<br>passengers 中的元素 互不相同 。</p><p>本人做法：<br>int latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity) {<br>   &#x2F;*<br>   总思路</p><ol><li>排序 将buses,passages数组从小到大排序</li><li>最晚时间到达 即<br>1&gt; 选择到达时间最晚的公交 即下标为N-1的数组<br>2&gt; 按照乘客到达的时间从早到晚依次将busessize-1量公交车乘客安排完毕<br>3&gt; 继续安排最后一辆公交车的乘客<br>   <em>&#x2F;<br>   &#x2F;</em><br>子问题一 排序 冒泡排序<br>1.依次比较i i+1两个元素的大小<br>1.1 若i &gt; i + 1,返回1<br>1.2 若i &lt; i + 1,交换二者位置<br>2.循环 n - 1 * n - 1次<br>   <em>&#x2F;<br>   &#x2F;*<br>   问题二 安排乘客<br>   1.从下标i &#x3D; 0 i&lt;busesSize-2 外层,j &#x3D; 0 内层 开始<br>   2.若*(buses + i)&gt;</em>(passengers + j)</li><li>j+1 z+1</li><li>z&#x3D;&#x3D;capacity或乘客不符合条件 i + 1<br>   *&#x2F;</li></ol><p>   int time; &#x2F;&#x2F;最晚到达时间<br>   int lasttime; &#x2F;&#x2F;原本最后一位乘客的抵达时间</p><p>   for(int j &#x3D; 0; j &lt; busesSize - 1; j++) {  &#x2F;&#x2F;公交车抵达时间排序<br>    for(int i &#x3D; 0; i &lt; busesSize - 1 - j; i++) {<br>        if(<em>(buses + i) &lt; *(buses + i + 1)) {<br>            continue;<br>        }<br>        else {<br>            int z &#x3D; *(buses + i);<br>            *(buses + i) &#x3D; *(buses + i + 1);<br>            *(buses + i + 1) &#x3D; z;<br>        }<br>    }<br>   }<br>    for(int j &#x3D; 0; j &lt; passengersSize - 1; j++) {    &#x2F;&#x2F;乘客到达时间排序<br>     for(int i &#x3D; 0; i &lt; passengersSize - 1 - j; i++) {<br>        if(*(passengers + i) &lt; *(passengers + i + 1)) {<br>            continue;<br>        }<br>        else {<br>            int z &#x3D; *(passengers + i);<br>            *(passengers + i) &#x3D; *(passengers + i + 1);<br>            *(passengers + i + 1) &#x3D; z;<br>        }<br>    }<br>   }<br>    int j1 &#x3D; 0;<br>    int i &#x3D; 0;<br>    int q &#x3D; capacity;<br>    for(i &#x3D; 0; i &lt;&#x3D; busesSize-2; i++){  &#x2F;&#x2F;除最后一辆车外安排好其余乘客 j表示倒数第二辆车的最后一位乘客下标<br>        for(q &#x3D; capacity; q &gt; 0; q–){<br>            if(</em>(passengers + j1) &lt; *(buses + i)){   &#x2F;&#x2F;如果乘客到达时间小于公交车到达时间<br>                j1++;<br>            }<br>            else{<br>                break;<br>            }<br>        }<br>    }<br>    int j &#x3D; j1 - 1;</p><pre><code>if(passengersSize - j1 &gt;=capacity)&#123;    for(int c = capacity; c &gt; 0; c--)&#123;        if(*(passengers + j + c) - 1 != *(passengers + j + c - 1))&#123;            time = *(passengers + j + c) - 1;            break;        &#125;        else if(c == 1)&#123;            time = *(passengers + j + 1) - 1;  //极端情况，安排乘客抵达时间在第一个乘客前            break;        &#125;    &#125;&#125;</code></pre><p>   return time;</p><p>}</p><p>官方解答：<br>int compare(const void <em>a, const void <em>b) {<br>    return (</em>(int</em>)a - <em>(int</em>)b);<br>}</p><p>int latestTimeCatchTheBus(int* buses, int busesSize, int* passengers, int passengersSize, int capacity) {<br>    qsort(buses, busesSize, sizeof(int), compare);  &#x2F;&#x2F;公交车到达时间排序<br>    qsort(passengers, passengersSize, sizeof(int), compare);    &#x2F;&#x2F;乘客到达时间排序<br>    int pos &#x3D; 0;    &#x2F;&#x2F;第pos位乘客上车<br>    int space &#x3D; 0;  &#x2F;&#x2F;公交车容量</p><pre><code>for (int i = 0; i &lt; busesSize; i++) &#123;    int arrive = buses[i];  //第i（从0开始计数）量车情况    space = capacity;   //每辆公交车初始容量为capacity    while (space &gt; 0 &amp;&amp; pos &lt; passengersSize &amp;&amp; passengers[pos] &lt;= arrive) &#123;        //乘客上车条件：如果剩余容量&gt;0,还有乘客未走，以及乘客抵达时间&lt;=公交车到达时间        //反之若不满足任意条件，即，该辆公交车容量已满，或已经没有乘客，或乘客到达时间晚于公交车时间，跳出循环，转为下一辆车        space--;        pos++;        //在比较完下标为0的乘客时，pos = 1,已经指向下一位乘客数组下标，所以比到最后一位时，pos的值也会比下标大1，代表走了第几位（1开始计数）乘客    &#125;&#125;pos--;  //指向最后一位上车乘客的元素int lastCatchTime = space &gt; 0 ? buses[busesSize - 1] : passengers[pos];//space也可代表最后一辆公交车的剩余容量情况while (pos &gt;= 0 &amp;&amp; passengers[pos] == lastCatchTime) &#123;    pos--;    lastCatchTime--;&#125;return lastCatchTime;</code></pre><p>}</p><p>代码解读：</p><p>qsort – 用于数组排序的函数 英语quick sort快速排序<br>一、头文件<br>#include&lt;stdlib.h&gt;<br>二、格式<br>int cmp(const void <em>a,const void <em>b) {<br>    return <em>(int</em>)a-</em>(int</em>)b;<br>}<br>qsort(num, n, sizeof(int), cmp);<br>包含四个参数(数组名, 数组长度，数组元素数据类型所占字节，排序原则)<br>使用方法：<br>定义一个函数cmp(自命名)，通过cmp返回的参数确定排序规则，其中cmp函数的参数需要以(const void <em>a,consi void <em>b)的形式定义，表示a,b变量的数据类型未知，在return返回时，用强制类型转换转换为int型，</em>(int</em>)a - <em>(int</em>)b 表示递增顺序,同理，*(int*)b - <em>(int</em>)a 表示递减顺序<br>排序原则：<br>根据要排序数组元素数据类型的不同，可分为四种<br>1.int型<br>int cmp(const void <em>a,const void <em>b) {<br>    return <em>(int</em>)a-</em>(int</em>)b;<br>}<br>2.double型<br>int cmp(const void <em>a,const void <em>b) {<br>    return <em>(double</em>)a&gt;</em>(double</em>)b?1:-1;<br>}<br>需要注意浮点数会存在精度损失的问题，所以我们需要通过比较，来返回1或-1，以确定是增序还是降序。<br>3.char型<br>int cmp(const void <em>a,const void <em>b) {<br>    return <em>(char</em>)a-</em>(char</em>)b;<br>}<br>4.结构体型<br>struct node{<br>    int i;<br>    double j;<br>    char k;<br>};<br>int cmp(const void <em>a,const void <em>b) {<br>    return (</em>(node</em>)a).i-(<em>(node</em>)b).i;<br>}<br>深度剖析：<br>void qsort(void* base, &#x2F;&#x2F;指向了待排序数组的第一个元素<br>           size_t num,   &#x2F;&#x2F;待排序的元素个数<br>           size_t size, &#x2F;&#x2F;每个元素的大小，单位是字节<br>           int (* cmp)(const void*, const void*) &#x2F;&#x2F;指向一个函数，这个函数可以比较2个元素的大小<br>          );<br>返回类型void:我们改变的是数列的排序，实际只需要进行内存的操作，所以不需要返回值。<br>void* base:表示应传入初始地址，至于为什么是void类型，它不知道我们会传入什么数据，而void类型就像一个垃圾桶一样什么地址都可以仍进去，所以只能用void*类型。<br>size_t num:num数量，表示应传入的元素个数<br>size_t width:width宽度，表示应传入的每个元素占的字节大小<br>int (*cmp)(const void *, const void *):<br>应传入一个比较函数地址，用于比较两个数据的大小，因为传入的数据类型是不确定的，所以我们需要自己定义一个比较函数传到qsort比较函数里面去，以便它知道怎么样去比较两个数据的大小。</p><p>qsort可以排序任意类型的数据<br>比较2个整数的大小，&gt; &lt; &#x3D;&#x3D;<br>比较2个字符串的大小，strcmp<br>比较2个结构体数据（学生：张三，李四）指定比较的标准</p><p>const void <em>a<br>关键字 const<br>作用：用const修饰的变量或对象的值不能再被改变<br>根据数据类型的不同分为：<br>1.修饰普通变量<br>const int n&#x3D;5;<br>注意：用const修饰变量时，一定要给变量初始化，否则之后不能再进行赋值<br>int const n&#x3D;5;<br>两种情况，n的值都不能再被改变<br>2.修饰指针<br>    1&gt;常量指针：指针指向的内容是常量<br>        const int * n;<br>        int const * n;<br>    注意：仅仅指 指针指向的内容为常量，相当于，常量指针指向哪个变量，哪个变量的值不能被改变，但是不能通过这个指针改变变量的值，但还是可以通过其他的引用来改变变量的值 【存疑-那常量指针的意义在哪】<br>        int a&#x3D;5;<br>        const int</em> n&#x3D;&a;<br>        a&#x3D;6;<br>    2&gt;指针常量：指针自己是常量，即只能指向一个地址，但指向的内容可以改变<br>        int a&#x3D;5;<br>        int <em>p&#x3D;&a;<br>        int</em> const n&#x3D;&a;<br>        <em>p&#x3D;8;<br>区分指针常量，常量指针：字面翻译<br>    const int * n; 先常量后指针，常量指针<br>    int</em> const n&#x3D;&a; 先指针后常量，指针常量，指针（是）常量</p><p><em>(int</em>)a-<em>(int</em>)b<br>    (int*)a :强制类型转换，将a的数据类型强制转换成整型指针<br>    强制类型转换：(type_name) expression 即 (要转换的目标类型)被转换的变量或表达式</p><p>学习心得：<br>循环条件有顺序，eg:while (pos &gt;&#x3D; 0 &amp;&amp; passengers[pos] &#x3D;&#x3D; lastCatchTime) 判断完第一个条件符合后才进行第二个条件<br>所以必要的边界条件先写，再写后面的逻辑约束条件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题描述：给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公</summary>
      
    
    
    
    
  </entry>
  
</feed>
