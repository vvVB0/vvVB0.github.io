<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vvVB0</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-18T14:04:26.190Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CLL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>05-dp</title>
    <link href="http://example.com/posts/c1f74d24.html"/>
    <id>http://example.com/posts/c1f74d24.html</id>
    <published>2024-11-18T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.190Z</updated>
    
    <content type="html"><![CDATA[<p>思想：拆分子问题，记住过往，减少重复计算。</p><p>典型特征：<br>最优子结构、状态转移方程、边界、重叠子问题<br>eg：<br>f(n-1)和f(n-2) 称为 f(n) 的最优子结构<br>f(n)= f（n-1）+f（n-2）就称为状态转移方程<br>f(1) = 1, f(2) = 2 就是边界<br>比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。</p><p>解题思路：<br>穷举分析<br>确定边界<br>找出规律，确定最优子结构<br>写出状态转移方程</p><p>1.穷举分析<br>拆分子问题：通过固定的方法如何得到目标<br>eg：<br>当台阶数是1的时候，有一种跳法，f（1） =1<br>当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;<br>当台阶是3级时，想跳到第3级台阶，要么是先跳到第2级，然后再跳1级台阶上去，要么是先跳到第 1级，然后一次迈 2 级台阶上去。所以f(3) = f(2) + f(1) =3<br>当台阶是4级时，想跳到第3级台阶，要么是先跳到第3级，然后再跳1级台阶上去，要么是先跳到第 2级，然后一次迈 2 级台阶上去。所以f(4) = f(3) + f(2) =5<br>当台阶是5级时……</p><p>2.确定边界<br>当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n&gt;=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。</p><p>3.找规律，确定最优子结构<br>n&gt;=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。</p><p>4.写出状态转移方程<br>f(n) = 1;n = 1<br>f(n) = 2;n = 2<br>f(n) = f(n - 1)f(n - 2); n &gt;= 3</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;思想：拆分子问题，记住过往，减少重复计算。&lt;/p&gt;
&lt;p&gt;典型特征：&lt;br&gt;最优子结构、状态转移方程、边界、重叠子问题&lt;br&gt;eg：&lt;br&gt;f(n-1)和f(n-2) 称为 f(n) 的最优子结构&lt;br&gt;f(n)= f（n-1）+f（n-2）就称为状态转移方程&lt;br&gt;f(1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2.小鱼的数字游戏</title>
    <link href="http://example.com/posts/c597fda3.html"/>
    <id>http://example.com/posts/c597fda3.html</id>
    <published>2024-11-18T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.212Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>输入格式<br>一行内输入一串整数，以 0 结束，以空格间隔。<br>输出格式<br>一行内倒着输出这一串整数，以空格间隔。<br>代码：<br>//18</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>int main(){<br>    int a[101];<br>    int i = 0;<br>    do{<br>        cin&gt;&gt;a[i];<br>        i++;<br>    }while(a[i - 1] != 0);</p><pre><code>//倒着输出for(int j = i - 2; j &gt;= 0; j--)&#123;    cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;&#125;</code></pre><p>}<br>知识点：<br>do{…}while() 翻译 = 做某件事，当满足括号里的条件时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;输入格式&lt;br&gt;一行内输入一串整数，以 0 结束，以空格间隔。&lt;br&gt;输出格式&lt;br&gt;一行内倒着输出这一串整数，以空格间隔。&lt;br&gt;代码：&lt;br&gt;//18&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;heade</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2.过河卒</title>
    <link href="http://example.com/posts/1344076c.html"/>
    <id>http://example.com/posts/1344076c.html</id>
    <published>2024-11-18T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.222Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。<br>棋盘用坐标表示，A 点 (0,0),B 点 (n,m)，同样马的位置坐标是需要给出的。<br>现在要求你计算出卒从 A 点能够到达 B 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。<br>输入格式<br>一行四个正整数，分别表示 B 点坐标和马的坐标。<br>输出格式<br>一个整数，表示所有的路径条数。<br><img src="pic/2.过河卒.png" alt="alt text"></p><p>dp思路<br>设当前点为（i，j）<br>最优子结构：(i-1,j) (i,j-1)两种路径可以到达<br>状态转移方程：（i，j） = (i-1,j)或(i,j-1)<br>边界 ：B 点 (n,m)，以及特殊情况马的范围</p><p>//01</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/<em><br>1.标记马的范围<br>2.遍历点 </em>/<br>bool vis[25][25];<br>long long dp[25][25];<br>int main(){<br>    int n,m,x,y;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;<br>    n++;<br>    m++;<br>    x++;<br>    y++;<br>    vis[x][y] = 1;<br>    vis[x-2][y-1]=1;<br>    vis[x-2][y+1]=1;<br>    vis[x+2][y-1]=1;<br>    vis[x+2][y+1]=1;<br>    vis[x-1][y+2]=1;<br>    vis[x-1][y-2]=1;<br>    vis[x+1][y+2]=1;<br>    vis[x+1][y-2]=1;</p><pre><code>dp[0][1] = 1;for(int i = 1; i &lt;= n; i++)&#123;    for(int j = 1; j &lt;= m; j++)&#123;        if(!vis[i][j])&#123;            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        &#125;    &#125;&#125;cout&lt;&lt;dp[n][m];</code></pre><p>} </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。&lt;br&gt;棋盘用坐标表示，A 点 (0,0),B 点 (n,m</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1.小鱼比可爱</title>
    <link href="http://example.com/posts/ad1413b6.html"/>
    <id>http://example.com/posts/ad1413b6.html</id>
    <published>2024-11-14T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.207Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。<br>输入格式：<br>第一行输入一个正整数n，表示鱼的数目。</p><p>第二行内输入 n个正整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度 </p><p>输入输出样例<br>6                   输出 0 0 0 3 1 2<br>4 3 0 5 1 2   </p><p>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></h1><p>int main(){<br>    int n;<br>    scanf(“%d”,&amp;n);<br>    int nums[n];<br>    int result[n];<br>    for(int i = 0; i &lt; n; i++){<br>        scanf(“%d”,&amp;nums[i]);<br>        int temp = 0;<br>        for(int j = 0; j &lt; i; j++){<br>            if(nums[i] &gt; nums[j]){<br>                temp++;<br>            }<br>        }<br>        result[i] = temp;<br>    }<br>    for(int i = 0; i &lt; n; i++){<br>        printf(“%d “,result[i]);<br>    }<br>    return 0;<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>1.数楼梯</title>
    <link href="http://example.com/posts/8587ce5c.html"/>
    <id>http://example.com/posts/8587ce5c.html</id>
    <published>2024-11-14T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.215Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>楼梯有 N 阶，上楼可以一步上一阶，也可以一步上二阶。<br>编一个程序，计算共有多少种不同的走法。<br>输入格式 一个数字，楼梯数。<br>输出格式 输出走的方式总数。<br>输入输出样例<br>4       5</p><p>代码：<br>//36</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>int main(){<br>    //输入楼梯数量<br>    int n;<br>    scanf(“%d”,&amp;n);</p><pre><code>//特殊情况if(n == 1 || n == 2 ||n == 0)&#123;    cout&lt;&lt;n;    return 0;&#125; //计算方法数量 高精度加法 存储在string 转为int[] 相加到int[]去前导零 dp1变为dp1,之和变为dp1 string dp0 = &quot;1&quot;;string dp1 = &quot;2&quot;;for(int i = 2; i &lt; n; i++)&#123;    int a[5005] = &#123;0&#125;,b[5005] = &#123;0&#125;;    int temp[5005] = &#123;0&#125;;    for(int j = 0; j &lt; dp0.size(); j++)&#123;        a[dp0.size() - 1 - j] = dp0[j] - &#39;0&#39;;    &#125;    for(int j = 0; j &lt; dp1.size(); j++)&#123;        b[dp1.size() - 1 - j] = dp1[j] - &#39;0&#39;;    &#125;    int max = dp0.size() &gt; dp1.size() ? dp0.size() : dp1.size();    for(int j = 0; j &lt; max; j++)&#123;        temp[j] += a[j] + b[j];        temp[j + 1] = temp[j] / 10 ;        temp[j] = temp[j] % 10;    &#125;    if(temp[max] &gt; 0)&#123;        max++;    &#125;    dp0 = dp1;    dp1 = &quot;&quot;;    for(int j = max - 1; j &gt;= 0; j--)&#123;        dp1 += to_string(temp[j]);    &#125;&#125;cout&lt;&lt;dp1;</code></pre><p>}<br>错误点：<br>1.字符串初始化 用”” 而不是’’<br>2.字符串转数字 dp1 += to_string(temp[j]);<br>    错误写法: dp1[j] = to_string(temp[j]);错误原因：不能将string类型转为char类型<br>    to_string赋值的对象是字符串，而dp1[j]具体成了一个char类型的字符<br>3.题目数值范围未搞清楚 超出long long 范围 -2^63~2^63-1后就要进行高精度加法运算 long(int) -2^31~2^31-1<br>    1&gt;两个加数长度位置，用字符串类型存储<br>    2&gt;将加数逆序转换为数值存入数组<br>    3&gt;进行相加，存入整型数组（仍为逆序），注意最高位是否产生进位，若是，则数组长度要加一<br>        int a[5005] = {0},b[5005] = {0};<br>        int temp[5005] = {0};<br>        for(int j = 0; j &lt; dp0.size(); j++){<br>            a[dp0.size() - 1 - j] = dp0[j] - ‘0’;<br>        }<br>        for(int j = 0; j &lt; dp1.size(); j++){<br>            b[dp1.size() - 1 - j] = dp1[j] - ‘0’;<br>        }<br>        int max = dp0.size() &gt; dp1.size() ? dp0.size() : dp1.size();<br>        for(int j = 0; j &lt; max; j++){<br>            temp[j] += a[j] + b[j];<br>            temp[j + 1] = temp[j] / 10 ;<br>            temp[j] = temp[j] % 10;<br>        }<br>        if(temp[max] &gt; 0){<br>            max++;<br>        }<br>解题思路：<br>相当于动态规划 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;楼梯有 N 阶，上楼可以一步上一阶，也可以一步上二阶。&lt;br&gt;编一个程序，计算共有多少种不同的走法。&lt;br&gt;输入格式 一个数字，楼梯数。&lt;br&gt;输出格式 输出走的方式总数。&lt;br&gt;输入输出样例&lt;br&gt;4       5&lt;/p&gt;
&lt;p&gt;代码：&lt;br&gt;//36&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>15.垂直柱状图</title>
    <link href="http://example.com/posts/71fcaa9a.html"/>
    <id>http://example.com/posts/71fcaa9a.html</id>
    <published>2024-11-06T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.202Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="pic-洛谷字符串/15.垂直柱状图.png" alt="alt text"><br>题目：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/<em>44</em>/<br>int amount(int nums[],string s){<br>    /<em>for(long i = 0; i &lt; s.size();i++){ //这种方式会报错<br>        nums[s[i] - ‘A’]++;<br>    }</em>/</p><pre><code>for(long i=0;i&lt;s.length();i++)&#123; //这种不会    for(int j=0;j&lt;26;j++)&#123;        if(s[i]-65==j)&#123;            nums[j]++;        &#125;    &#125;&#125;return *nums; //!注意返回数组时在数组名前面加*</code></pre><p>}<br>int main(){<br>    //读入四行字符串<br>    string s1,s2,s3,s4;<br>    getline(cin,s1);<br>    getline(cin,s2);<br>    getline(cin,s3);<br>    getline(cin,s4);</p><pre><code>//统计字母数量int nums[26] = &#123;0&#125;;amount(nums,s1);amount(nums,s2);amount(nums,s3);amount(nums,s4);//输出int max = 0;for(int i = 0; i &lt; 26; i++)&#123;    max = max &gt; nums[i] ? max : nums[i];&#125;for(int i = max; i &gt; 0; i--)&#123;    for(int j = 0; j &lt; 26; j++)&#123;        if(nums[j] &gt;= i)&#123;            printf(&quot;* &quot;);            nums[j]--;        &#125;        else&#123;            printf(&quot;  &quot;);        &#125;    &#125;    printf(&quot;\n&quot;);&#125;cout&lt;&lt;&quot;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&quot;;return 0;</code></pre><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;pic-洛谷字符串/15.垂直柱状图.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;题目：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;include</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>6.红和蓝</title>
    <link href="http://example.com/posts/a7aa720.html"/>
    <id>http://example.com/posts/a7aa720.html</id>
    <published>2024-11-05T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.228Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/6.红和蓝.png" alt="alt text"><br>代码：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;pic-牛客/6.红和蓝.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>14.语句解析</title>
    <link href="http://example.com/posts/13921496.html"/>
    <id>http://example.com/posts/13921496.html</id>
    <published>2024-11-03T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.197Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="pic-洛谷字符串/14.语句解析.png" alt="alt text"><br>代码：<br>c++</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/*</p><p>*/<br>int main(){<br>    string s;<br>    getline(cin,s);<br>    map<char,string>q;<br>    q[‘a’] = ‘0’;<br>    q[‘b’] = ‘0’;<br>    q[‘c’] = ‘0’;<br>    for(int i = 0; i <s.size(); i++){        if(s[i] == '='){            if(s[i + 1] < '0' || s[i + 1] > ‘9’){//如果赋值的是变量 a:=b<br>                q[s[i - 2]] = q[s[i + 1]];<br>            }<br>            else{<br>                q[s[i - 2]] = s[i + 1];<br>            }<br>        }<br>    }<br>    cout&lt;&lt;q[‘a’]&lt;&lt;” “&lt;&lt;q[‘b’]&lt;&lt;” “&lt;&lt;q[‘c’]&lt;&lt;endl;</p><pre><code>return 0;</code></pre><p>}<br>法二：</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<cstdio></h1><p>using namespace std;<br>int a[3];char s1,s2;<br>int main()<br>{<br>    while (scanf(“%c:=%c;”,&amp;s1,&amp;s2)==2)//<br>     a[s1-‘a’]=s2&gt;=’0’ &amp;&amp; s2&lt;=’9’ ? s2-‘0’ : a[s2-‘a’]; //赋值语句简洁明了<br>    printf(“%d %d %d”,a[0],a[1],a[2]);<br>}</p><p>c语言</p><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <string.h></h1><p>int main(){<br>    int a[3] = {0};<br>    char s1,s2;<br>    while(scanf(“%c:=%c;”,&amp;s1,&amp;s2) == 2){<br>        a[s1 - ‘a’] = s2 &gt;= ‘0’ &amp;&amp; s2 &lt;= ‘9’ ? s2 - ‘0’ : a[s2 - ‘a’];<br>    }<br>    printf(“%d %d %d”,a[0],a[1],a[2]);<br>    return 0;<br>}</p><p>知识点：<br>1.scanf(“%c:=%c;”,&amp;s1,&amp;s2)==2</p><p>这行代码的格式字符串 “%c:=%c;” 包含以下几个部分：</p><p>%c：这是一个格式说明符，告诉 scanf 读取一个字符并将其存储在提供的地址（&amp;s1）。</p><p>:=：这是普通的字符，scanf 会从输入中读取这两个字符，但不会将它们存储在任何地方。它们在这里的作用是确保输入中包含这两个字符。</p><p>%c：这是另一个格式说明符，告诉 scanf 读取一个字符并将其存储在提供的地址（&amp;s2）。</p><p>;：这是普通的字符，scanf 会从输入中读取这个字符，但不会将其存储在任何地方。它在这里的作用是确保输入以分号结束。</p><p>scanf 函数返回成功匹配的输入项的数量。在这个例子中，格式字符串期望两个字符（由 %c 指定），所以如果输入正确，scanf 应该返回 2。这个返回值然后与 2 进行比较，以确保两个字符都已成功读取。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;pic-洛谷字符串/14.语句解析.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;br&gt;c++&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>13.你的飞碟在这儿 Your Ride Is Here</title>
    <link href="http://example.com/posts/777cdf84.html"/>
    <id>http://example.com/posts/777cdf84.html</id>
    <published>2024-11-01T14:06:56.000Z</published>
    <updated>2024-11-14T12:09:10.533Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><a href="13.你的飞碟在这儿 Your Ride Is Here.md">text</a><br>代码：<br>c++</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>int data(string s){<br>    int num = 1;<br>    for(int i = 0; i &lt; s.size(); i++){<br>        num = num * (s[i] - ‘A’ + 1);<br>    }<br>    return num;<br>}</p><p>int main(){<br>    string s1;<br>    string s2;<br>    cin&gt;&gt;s1&gt;&gt;s2;</p><pre><code>int num1 = data(s1);//彗星 int num2 = data(s2);//小组 if(num2 % 47 == num1 %47)&#123;    cout&lt;&lt;&quot;GO&quot;;&#125;else cout&lt;&lt;&quot;STAY&quot;;return 0;</code></pre><p>}</p><p>c</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <stdlib.h></h1><p>int data(char s[]){<br>    int num = 1;<br>    for(int i = 0; s[i] != ‘\0’; i++){ //知识点2<br>        num = num * (s[i] - ‘A’ + 1);<br>    }<br>    return num;<br>}</p><p>int main(){<br>    char s1[100];  //知识点1<br>    char s2[100];</p><pre><code>scanf(&quot;%s %s&quot;,s1,s2);int num1 = data(s1);int num2 = data(s2);if(num2 % 47 == num1 % 47)&#123;    printf(&quot;GO&quot;);&#125;else printf(&quot;STAY&quot;);return 0;</code></pre><p>}</p><p>知识点：</p><ol><li>c语言 虽然char a[] 每个元素只能存储一个字符，但是可以多位输入<br>2.for(int i = 0; s[i] != ‘\0’; i++) 遍历char数组，用’\0’来判断结束</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;a href=&quot;13.你的飞碟在这儿 Your Ride Is Here.md&quot;&gt;text&lt;/a&gt;&lt;br&gt;代码：&lt;br&gt;c++&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>03-埃拉托斯特尼筛法</title>
    <link href="http://example.com/posts/7a2fccc2.html"/>
    <id>http://example.com/posts/7a2fccc2.html</id>
    <published>2024-10-31T12:03:50.394Z</published>
    <updated>2024-11-18T14:04:26.194Z</updated>
    
    <content type="html"><![CDATA[<p>埃拉托斯特尼筛法（Sieve of Eratosthenes）:<br>1.目的：用于找出一定范围内所有质数的算法<br>2.基本思想：从小到大逐个筛选数，将合数（非质数）标记掉，最终剩下的即为质数。<br>3.详细解释：</p><p>1&gt;初始化：<br>创建一个长度为n+1的布尔数组（通常称为isPrime或prime），初始值全部设置为true，表示所有数都是质数。<br>筛选过程：</p><p>2&gt;从2开始，将第一个质数2标记为质数（true），然后将2的所有倍数标记为非质数（false）。<br>然后找到下一个未被标记的数，即下一个质数3，将其标记为质数，然后将3的所有倍数标记为非质数。<br>依次类推，直到遍历完所有小于等于n的数。</p><p>3&gt;筛选规则：<br>对于每个质数p，将其所有大于等于p^2且小于等于n的倍数标记为非质数。<br>这是因为：<br>1.如果一个数 x 是质数 p 的倍数，并且 x &lt; p <em> p，那么 x 可以表示为 x = p </em> k，其中 k 是一个小于 p 的数。<br>2.在之前处理质数 k 时，已经标记过 k 的所有倍数，包括 p <em> k。<br>3.因此，p </em> k 已经在处理 k 时被标记为非质数，而且 k &lt; p，所以 p <em> k &lt; p </em> p。<br>4.因此，在处理质数 p 时，小于 p <em> p 的 p 的倍数已经被标记过了，不需要再次标记。<br>eg: i = 2 标记 4 6 8…<br>    i = 3 从9开始 因为 2</em>3 = 6 在遍历2的时候就已经遍历了<br>    换言之，一个数的因子，除了根号外 一定一个大一个小，在求倍数的时候，从小的开始遍历，再到大的时候就标记从以这个数作为小因数开始的倍数即可</p><p>4&gt;结果提取：<br>最终留下的isPrime[i]为true的数i即为质数。</p><p>4.复杂度：<br>埃拉托斯特尼筛法的时间复杂度为O(n log log n)，其中n为要筛选的范围内的数的个数。</p><p>这种算法的优点在于简单易懂，且在一定范围内找质数的效率很高。然而，对于大范围内的质数筛选，其他更高效的算法可能更合适。</p><p>代码：<br>const int MAX = 1000005;<br>bool prime[MAX];<br>void init() {<br>    memset(prime,true,sizeof prime); //知识点<br>    for(int i=2; i<em>i&lt;MAX; i++) { //目的是标记倍数，当以i为小因数开始的倍数以及大于范围时，就没有标记的范围了 换言之，i就是最大的因数<br>        if(prime[i]) {//是素数<br>            for(int j=i</em>2; j&lt;MAX; j+=i)//从2倍开始，n倍<br>                prime[j]=false;//各个倍数<br>        }<br>    }<br>}</p><p>解释：为什么i*i&lt;MAX;<br>在埃拉托斯特尼筛法中，当我们处理质数 p 时，我们只需要标记 p 的倍数，其中 p 的平方小于或等于 n。这是因为如果 p 的平方大于 n，那么 p 的倍数已经超出了我们要筛选的范围，不需要再标记这些倍数。</p><p>举个例子：</p><p>假设我们要找出小于等于 30 的所有质数：</p><p>当处理质数 2 时，我们从 2 的平方开始标记倍数，即从 4 开始。因为 2 的平方是 4，小于等于 30，所以我们需要标记 2 的倍数。<br>当处理质数 3 时，我们从 3 的平方开始标记倍数，即从 9 开始。因为 3 的平方是 9，小于等于 30，所以我们需要标记 3 的倍数。<br>当处理质数 5 时，我们从 5 的平方开始标记倍数，即从 25 开始。因为 5 的平方是 25，小于等于 30，所以我们需要标记 5 的倍数。<br>如果我们考虑一个更大的质数，比如 7，7 的平方是 49，大于 30，这意味着 7 的倍数已经超出了我们要筛选的范围，因此不需要再标记 7 的倍数。<br>因此，为了确保我们在筛选范围内正确地标记质数的倍数，我们需要保证 p 的平方小于或等于我们要筛选的最大值 n。</p><p>知识点：<br>一.memset()函数<br>1.作用：用于将一块内存空间的每个字节都设置为指定的值<br>2.用法：memset(初始地址,要设的值,类型长度) eg:memset(prime,true,sizeof prime);</p><p>注意点：在C++中，memset函数经常用来初始化整型数组、字符数组或其他基本数据类型的数组。但对于非整型数据类型，如bool类型，使用memset可能会导致一些问题，因为bool类型在C++中并不是一个字节大小的数据类型，而是一个字节中的某一位。因此，对于bool类型数组，最好使用循环或其他方法显式地设置每个元素的值。<br>3.头文件：<cstring></p><p>扩展：std::fill 函数<br>1.作用：是 C++ 标准库中的一个函数模板，它用于将指定的值赋给一个容器或数组的特定范围内的所有元素<br>2.头文件：<algorith><br>3.用法：<br>eg:vector<int> vec(5);<br>    fill(vec.begin(), vec.end(), -1); // 将 vector 中的每个元素都设置为 -1</p><p>fill()函数和memset()函数的区别<br>1.std::fill<br>是 C++ 标准库中的一个模板函数，定义在 <algorithm> 头文件中。<br>可以用于任何类型的容器，包括数组、std::vector、std::list、std::array 等。<br>可以填充任何类型的值，不仅仅是字节值。<br>需要两个迭代器参数来指定要填充的元素范围。<br>安全性更高，因为它基于类型，编译器会检查类型匹配，减少类型错误的风险。<br>2.memset<br>是 C 语言标准库中的一个函数，定义在 <cstring> 头文件中。<br>通常用于填充字节序列，适用于简单的数据类型（如 char、unsigned char 等）。<br>不能用于填充复杂数据类型，因为它只处理字节级别的赋值。<br>只需要一个指针参数指向要填充的内存块的开始位置，以及要设置的值和要填充的字节数。<br>效率可能更高，因为它直接操作内存，不涉及迭代器的解引用和递增操作。</p><p>二.i++和++i的区别<br>++i：返回 i 增加 1 后的值<br>i++：返回 i 增加 1 之前的值<br>eg:<br>i  = 1;<br>int a = ++i;  // i 现在是 2，a 是 2</p><p>i  = 1;<br>int b = i++;  // i 现在是 2，但 b 是 1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;埃拉托斯特尼筛法（Sieve of Eratosthenes）:&lt;br&gt;1.目的：用于找出一定范围内所有质数的算法&lt;br&gt;2.基本思想：从小到大逐个筛选数，将合数（非质数）标记掉，最终剩下的即为质数。&lt;br&gt;3.详细解释：&lt;/p&gt;
&lt;p&gt;1&amp;gt;初始化：&lt;br&gt;创建一个长</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>03-DFS算法</title>
    <link href="http://example.com/posts/1c45da2f.html"/>
    <id>http://example.com/posts/1c45da2f.html</id>
    <published>2024-10-30T12:49:11.985Z</published>
    <updated>2024-11-18T14:04:26.182Z</updated>
    
    <content type="html"><![CDATA[<p>引入：<br>递归代码模板：<br>1.先写出口<br>2.再写普通相同情况<br>eg: 斐波那契数列 1 2 5 8 13…<br>int fibo(int a){<br>    if(a == 0 || a == 1){  //先写出口<br>        return 1;<br>    }<br>    else{<br>        return fibo(a - 1) + fibo( a - 2);<br>    }<br>}<br>思考是否具有递归特性：<br>1&gt;思考普遍情况<br>1.当为极端情况时(自下而上 最”下”的情况)的情况 eg:跳台阶，只有一个台阶<br>2.当为极端条件 + 1 时的情况 eg:跳台阶，有两个台阶</p><ol><li>…<br>2&gt;<br>推及到n时，(n - 1)对n的情况，是否只要知道了(n - 1),或(n - 2)等等以此类推 就能根据普遍情况得到n</li></ol><p>换言之，即 想要得到n的结果，是否需要得到(n - 1/2/3/..)的结果</p><p>DFS—深度优先算法<br>大概思路：不撞南墙不回头 依次走完所有路<br>eg：</p><ol><li>kotori和素因子（A组，B组）<br>void dfs(int d,int sum){//重点<br> if(d == n){//先写退出条件—深度达到最大值<pre><code> ans = min(ans,sum); return;</code></pre> }<br> for(int i = 0; i &lt; v[d].size(); i++){//从最底层开始，一次选一个值<pre><code> if(!vis[v[d][i]])&#123;     vis[v[d][i]] = 1;//标记该值，表已经被用过     dfs(d + 1, sum + v[d][i]); //选完一个换下一个     vis[v[d][i]] = 0; //上一个选完后回头，换一个路，将之前标记过的值还原 &#125;</code></pre> }<br>}</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;引入：&lt;br&gt;递归代码模板：&lt;br&gt;1.先写出口&lt;br&gt;2.再写普通相同情况&lt;br&gt;eg: 斐波那契数列 1 2 5 8 13…&lt;br&gt;int fibo(int a){&lt;br&gt;    if(a == 0 || a == 1){  //先写出口&lt;br&gt;        retu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>02-KMP算法</title>
    <link href="http://example.com/posts/777cdf84.html"/>
    <id>http://example.com/posts/777cdf84.html</id>
    <published>2024-10-28T14:06:56.000Z</published>
    <updated>2024-11-01T12:47:14.076Z</updated>
    
    <content type="html"><![CDATA[<p>目的：在一个字符串中找一个字串<br>朴素暴力解法：<br>在主串中挨个找，匹配返回位置，不匹配回到下一个位置<br>问题：例如前面以及匹配过ab的组合，子串中也有ab,那么可以直接比较子串ab后面的字符和主串ab后面的字符,否则在挨个比较就重复了<br>故而提出<br>KMP算法：<br>1.需要得到前缀表 next[]数组<br>eg:设子串T=“aabaaf”，求T的前缀表 即next数组<br>1&gt;第一个子串 t0=“a”，没有前缀也没有后缀 next[0]=0<br>2&gt;第二个子串 t1=“aa”，前缀为”a”，后缀也为”a” next[1]=1<br>3&gt;第三个子串 t2=“aab”，该子串后缀中一定会有”b”，前缀中一定不含有”b”，没有相等的前后缀 next[2]=0<br>4&gt;第四个子串 t3=“aaba”，最大相等前后缀为”a”，长度为1，next[3]=1<br>5&gt;第五个子串 t4=“aabaa”，最大相等前后缀为”aa”，长度为2，next[4]=2<br>6&gt;第六个子串是t5=“aabaaf”，该子串的后缀中一定会有”f”，前缀中一定不含有”f”，则其没有相等的前后缀 next[5]=0</p><p>next[]数组的作用：到主串的j,子串的i 不匹配时，查next[j] = x 则子串的i回退到x这个位置(x表示比配过的相同前缀的下一个字符)</p><p>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int nextArr[100] = {0}; </p><p>/*<br>求字符串s每一个子串的最长相等前后缀的长度<br> i的每一次自增，代表的就是s的一个子串<br> 同时 i 也表示该子串的后缀结尾位置<br>  j = 0开始，j表示子串前缀结尾位置 即next[i]的值 此时j的位置不代表子串的末尾的前一个位置，而代表的是上一个子串相等前后缀的末尾位置的下一个字符<br>  前后缀相等，意味着长度，字符均相同，从结尾开始比较，只要不相同,后缀结尾不变，前缀结尾改变<br>  子串只有一个字符时，无前后缀，预先设置next[0] == 0<br>  从i=1 j=0开始（即从两个字符开始判断）<br>  判断s[j]  s[i]是否相等   不等j 依旧等于0 记录此时next[i] = j  相等j++ 指向等前后缀的末尾位置的下一个字符<br>  后期子串增加，判断s[j]  s[i]是否相等<br>  不等，意味着 之前的前缀的下一个字符现在字符后缀最后一个不限等，则跳转到上一个next[],即next[j - 1]<br>  因为之前的前缀是现在子串前缀的子集，若是之前匹配过。没有必要在匹配一次，直接判断后缀增结尾符改变后</p><p>*/</p><p>void Next(string s) {  //求next数组<br>    int n = s.size();<br>    int j = 0;<br>    for (int i = 1; i &lt; n; i++) {<br>        while (j &gt; 0 &amp;&amp; s[j] != s[i]) {<br>            j = nextArr[j - 1];<br>        }<br>        if (s[j] == s[i]) j++;<br>        nextArr[i] = j;<br>    }<br>}<br>//kmp匹配<br>bool kmp(int next[], string str, string s) {<br>    int j = 0;<br>    int n = s.size();<br>    for (int i = 0; i &lt; str.size(); i++) {<br>        while (j &gt; 0 &amp;&amp; str[i] != s[j]) {<br>            j = next[j - 1];<br>        }<br>        if (str[i] == s[j]) j++;<br>        if (j == n) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</p><p>int main() {<br>    string str, s;<br>    cin &gt;&gt; str &gt;&gt; s;<br>    Next(s);<br>    if (kmp(nextArr, str, s)) {<br>        cout &lt;&lt; s &lt;&lt; “是” &lt;&lt; str &lt;&lt; “的子串” &lt;&lt; endl;<br>    } else {<br>        cout &lt;&lt; s &lt;&lt; “不是” &lt;&lt; str &lt;&lt; “的子串” &lt;&lt; endl;<br>    }<br>    return 0;<br>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目的：在一个字符串中找一个字串&lt;br&gt;朴素暴力解法：&lt;br&gt;在主串中挨个找，匹配返回位置，不匹配回到下一个位置&lt;br&gt;问题：例如前面以及匹配过ab的组合，子串中也有ab,那么可以直接比较子串ab后面的字符和主串ab后面的字符,否则在挨个比较就重复了&lt;br&gt;故而提出&lt;br&gt;K</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组入门</title>
    <link href="http://example.com/posts/777cdf84.html"/>
    <id>http://example.com/posts/777cdf84.html</id>
    <published>2024-10-24T14:06:56.000Z</published>
    <updated>2024-11-01T12:46:25.721Z</updated>
    
    <content type="html"><![CDATA[<p>一.c++ —动态数组 std::vector (用using … std; std省略)<br>1.作用：封装了可以改变大小的数组，使其成为存储和管理动态数据集合的首选方式<br>2.用法： vector&lt;元素类型&gt;变量名;<br>3.常用操作：<br>1&gt;初始化<br>vector<int> v; // 创建一个空的 int 类型的 vector<br>vector<int> v(5, 10); // 创建一个包含 5 个元素的 vector，每个元素初始化为 10<br>vector<int> v = {1, 2, 3, 4, 5}; // 使用列表初始化<br>2&gt;添加元素(插入元素)<br>v.push_back(10); // 在 vector 的末尾添加一个元素<br>v.insert(v.begin(), 20); // 在 vector 的开头插入一个元素<br>3&gt;访问元素<br>int first = v.front(); // 获取 vector 的第一个元素<br>int last = v.back(); // 获取 vector 的最后一个元素<br>int element = v[3]; // 获取索引为 3 的元素<br>4&gt;删除元素<br>v.pop_back(); // 删除 vector 的最后一个元素<br>v.erase(v.begin() + 2); // 删除索引为 2 的元素<br>v.clear(); // 删除 vector 中的所有元素<br>5&gt;大小和容量<br>size_t size = v.size(); // 获取 vector 中的元素数量<br>size_t capacity = v.capacity(); // 获取 vector 的当前容量<br>v.resize(10); // 改变 vector 的大小为 10<br>6&gt;搜索和排序<br>auto it = find(v.begin(), v.end(), 10); // 搜索值为 10 的元素<br>if (it != v.end()) {<br>    // 元素找到<br>}<br>sort(v.begin(), v.end()); // 排序 vector 中的元素<br>7&gt;范围基于的 for 循环<br>for (int elem : v) {<br>    // 对 v 中的每个元素执行操作<br>}</p><p>注意：std::vector<string>v 和std::vector<string>v[5]的区别 前者为一位数组，后者就相当于5个长度不定的一维数组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一.c++ —动态数组 std::vector (用using … std; std省略)&lt;br&gt;1.作用：封装了可以改变大小的数组，使其成为存储和管理动态数据集合的首选方式&lt;br&gt;2.用法： vector&amp;lt;元素类型&amp;gt;变量名;&lt;br&gt;3.常用操作：&lt;br&gt;1&amp;g</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>11.数字反转（升级版）</title>
    <link href="http://example.com/posts/777cdf84.html"/>
    <id>http://example.com/posts/777cdf84.html</id>
    <published>2024-10-24T14:06:56.000Z</published>
    <updated>2024-10-25T13:03:02.894Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><a href="11.数字反转（升级版）.md">text</a><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>string transfer(string s){<br>    reverse(s.begin(), s.end()); //知识点1<br>    return s;<br>} </p><p>string zero(string s){<br>    int pos = s.find(‘0’);<br>    while(pos == 0 &amp;&amp; s.size() &gt; 1){<br>        s = s.erase(pos, 1);<br>        pos = s.find(‘0’);<br>    }<br>    return s;<br>}</p><p>int main(){<br>    string s, temp;<br>    cin &gt;&gt; s;<br>    int pos = s.find(‘.’);</p><pre><code>if (pos != string::npos) &#123; // 小数  //知识点2    temp = s;    s = s.substr(0, pos);    s = transfer(s);    s = zero(s) + temp[pos];    temp = temp.substr(pos + 1);    temp = zero(temp);    temp = transfer(temp);    //cout&lt;&lt;temp&lt;&lt;endl;    s = s + temp;&#125; else &#123;    pos = s.find(&#39;/&#39;);    if (pos != string::npos) &#123; // 分数        temp = s;        s = s.substr(0, pos);        s = transfer(s);        s = zero(s) + temp[pos];        temp = temp.substr(pos + 1);        temp = transfer(temp);        temp = zero(temp);        s = s + temp;    &#125; else &#123;        pos = s.find(&#39;%&#39;);        if (pos != string::npos) &#123; // 百分数            s = s.substr(0, s.size() - 1);  //知识点3            s = transfer(s);            s = zero(s) + &#39;%&#39;;        &#125; else &#123; // 整数            s = transfer(s);            s = zero(s);        &#125;    &#125;&#125;cout &lt;&lt; s;return 0;</code></pre><p>}</p><p>知识点：<br>1.reverse(s.begin(), s.end());<br>作用：将字符串s反转，eg:123 = 321<br>头文件：string (c++)</p><p>2.string::npos<br>作用：pos != string::npos 如果 pos 的值不等于 string::npos，则说明找到了对应的字符或子字符串。否则，表示未找到匹配。<br>在C++中，string::npos 表示 string 类型中的一个静态常量，通常用于表示未找到匹配的位置<br>注意：本身表示未找到，所以不等于才表示找到</p><p>3.s = s.substr(0, s.size() - 1);<br>作用：s.substr(起始位置，截取长度) 截取字符串  表示从0开始(包括0)，截取s.size() - 1个长度<br>头文件：string (c++)</p><p>总结：<br>1.写代码前 先思考 想出具体方法！！！以及易错点<br>例如: 去掉后面的0时，如果只判断0的位置是否在最后，则当前面有0时将无法判断<br>2.分模块实现，每写一个模块就进行测试，防止一错再错<br>3.不要过度依赖人工智能，自己判断错误</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;a href=&quot;11.数字反转（升级版）.md&quot;&gt;text&lt;/a&gt;&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;include &quot;&gt;&lt;/a&gt;include </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>12.斯诺登的密码</title>
    <link href="http://example.com/posts/777cdf84.html"/>
    <id>http://example.com/posts/777cdf84.html</id>
    <published>2024-10-24T14:06:56.000Z</published>
    <updated>2024-10-27T13:37:30.605Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><a href="pic-洛谷字符串/12.斯诺登的密码.png">alt text</a><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<cstring></h1><p>using namespace std;<br>/<em><br>1.输入，string 先对格式不做要求<br>2.找数字 存入数组中，利用for循环遍历 存储到数组<br>3.平方 取模 去0 </em>/<br>int main(){<br>    string s[6];<br>    string snum[26] = {“one”,”two”,”three”,”four”,”five”,”six”,”seven”,”eight”,”nine”,”ten”,”eleven”,”twelve”,”thirteen”,”fourteen”,”fifteen”,”sixteen”,”seventeen”,”eighteen”,”nineteen”,”twenty”,”a”,”both”,”another”,”first”,”second”,”third”};<br>    int num[26] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,1,2,1,1,2,3};<br>    int data[6] = {0};<br>    int j = 0;</p><pre><code>for(int i = 0; i &lt; 6; i++)&#123;    cin&gt;&gt;s[i];    for(int k = 0; k &lt; 26; k++)&#123; //为什么边界是26         if(s[i] == snum[k] &amp;&amp; (num[k] * num[k]) % 100 != 0)&#123;            data[j] = (num[k] * num[k]) % 100;            j++;            break;        &#125;    &#125;&#125;if(j == 0)&#123;    cout&lt;&lt;0;    return 0;&#125;sort(data, data + j);for(int i = 0; i &lt; j; i++)&#123;    if(i != 0 &amp;&amp; data[i] &lt; 10)&#123;        cout&lt;&lt;0;    &#125;    cout&lt;&lt;data[i];&#125;return 0;</code></pre><p>}</p><p>错误原因：<br>没有彻底搞清楚题目，导致走了很多弯路，简单问题复杂化<br>知识点 + 疑惑点：<br>string snum[26] 有26个元素，数组下标仍然为26.不为25，循环时，从0开始，K &lt; 26, for(int k = 0; k &lt; 26; k++)<br>解答：元素个数比下标大一 有26个元素，下标为0 ~ 25<br>在C和C++中，定义一个数组时，需要指定数组的大小，而不是数组中元素的数量。因此，当您定义数组时，需要指定数组的大小，以便为所有元素提供足够的空间。在定义数组时，指定数组的大小应该是数组中元素的数量，而不是最后一个元素的索引。</p><p>知识补充；<br>代码：</p><h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<iostream></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include"></a>include<cstdio></h1><h1 id="include-4"><a href="#include-4" class="headerlink" title="include"></a>include<cstring></h1><h1 id="include-5"><a href="#include-5" class="headerlink" title="include"></a>include<algorithm></h1><h1 id="include-知识点：map"><a href="#include-知识点：map" class="headerlink" title="include   //知识点：map"></a>include<map>   //知识点：map</h1><p>using namespace std;<br>map<string,int>q;<br>const int mx=66;<br>int top;<br>int st[mx];<br>string s;<br>int main(){</p><pre><code> q[&quot;one&quot;]=1;q[&quot;two&quot;]=2;q[&quot;three&quot;]=3;q[&quot;four&quot;]=4;q[&quot;five&quot;]=5;q[&quot;six&quot;]=6;q[&quot;seven&quot;]=7;q[&quot;eight&quot;]=8;q[&quot;nine&quot;]=9;q[&quot;ten&quot;]=10； q[&quot;eleven&quot;]=11;q[&quot;twelve&quot;]=12;q[&quot;thirteen&quot;]=13;q[&quot;fourteen&quot;]=14;q[&quot;fifteen&quot;]=15;q[&quot;sixteen&quot;]=16;q[&quot;seventeen&quot;]=17;q[&quot;eighteen&quot;]=18;q[&quot;nineteen&quot;]=19;q[&quot;twenty&quot;]=20; q[&quot;a&quot;]=1;q[&quot;both&quot;]=2;q[&quot;another&quot;]=1;q[&quot;first&quot;]=1;q[&quot;second&quot;]=2;q[&quot;third&quot;]=3; //打表 for(int i=1;i&lt;=6;i++)&#123;     cin&gt;&gt;s;     if(q[s])&#123;//如果可以构成数字         int k=q[s]*q[s]%100;         if(k==0)continue;//要是为0就没有必要存了         st[++top]=k;     &#125; &#125; sort(st+1,st+top+1);//从小到大排 cout&lt;&lt;st[1]; for(int i=2;i&lt;=top;i++)&#123;     if(st[i]&lt;10)cout&lt;&lt;0;//不这样只能拿10分     cout&lt;&lt;st[i]; &#125; return 0;</code></pre><p>}</p><p>知识点：map</p><p><map> 是标准模板库（STL）的一部分，它提供了一种关联容器，用于存储键值对（key-value pairs）。<br>map 容器中的元素是按照键的顺序自动排序的，这使得它非常适合需要快速查找和有序数据的场景</p><p>1.定义：map<key_type, value_type> myMap; 相当于：一个二元组对，第一列和第二列 利用map构成了一种一一对应的映射关系<br>eg：map<string,int>q;<br>2.使用/初始化：myMap[key] = value; 变量名[第一个元素值] = 第二个元素值;<br>eg: q[“one”]=1; q[“two”]=2; q[“three”]=3;</p><p>3.定义和特性<br>键值对：map 存储的是键值对，其中每个键都是唯一的。<br>排序：map 中的元素按照键的顺序自动排序，通常是升序。<br>唯一性：每个键在 map 中只能出现一次。<br>双向迭代器：map 提供了双向迭代器，可以向前和向后遍历元素。</p><ol><li>访问元素：value = myMap[key];<br>eg: int k=q[s]*q[s]%100;</li></ol><p>5.遍历元素：<br>for (map<key_type, value_type>::iterator it = myMap.begin(); it != myMap.end(); ++it) {<br>    cout &lt;&lt; it-&gt;first &lt;&lt; “ =&gt; “ &lt;&lt; it-&gt;second &lt;&lt; endl;<br>}</p><p>实例<br>下面是一个使用 map 的简单实例，我们将创建一个 map 来存储员工的姓名和他们的年龄，并遍历这个 map 来打印每个员工的姓名和年龄。</p><p>实例</p><h1 id="include-include"><a href="#include-include" class="headerlink" title="include #include "></a>include <iostream>#include <map></h1><h1 id="include-6"><a href="#include-6" class="headerlink" title="include "></a>include <string></h1><p>int main() {<br>    // 创建一个 map 容器，存储员工的姓名和年龄<br>    std::map<std::string, int> employees;</p><pre><code>// 插入员工信息employees[&quot;Alice&quot;] = 30;employees[&quot;Bob&quot;] = 25;employees[&quot;Charlie&quot;] = 35;// 遍历 map 并打印员工信息for (std::map&lt;std::string, int&gt;::iterator it = employees.begin(); it != employees.end(); ++it) &#123;    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; is &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl;&#125;return 0;</code></pre><p>}<br>输出结果:</p><p>Alice is 30 years old.<br>Bob is 25 years old.<br>Charlie is 35 years old.</p><p>进阶用法</p><p>6.检查键是否存在:<br>if (myMap.find(key) != myMap.end()) {<br>    // 键存在<br>}</p><p>7.删除元素:<br>myMap.erase(key);</p><p>8.清空:<br>myMap.clear();</p><p>9.获取 map 的大小:<br>size_t size = myMap.size();</p><p>10.使用自定义比较函数:</p><p>实例</p><h1 id="include-7"><a href="#include-7" class="headerlink" title="include "></a>include <map></h1><h1 id="include-8"><a href="#include-8" class="headerlink" title="include "></a>include <string></h1><h1 id="include-9"><a href="#include-9" class="headerlink" title="include "></a>include <functional></h1><p>bool myCompare(const std::string&amp; a, const std::string&amp; b) {<br>    return a &lt; b;<br>}</p><p>int main() {<br>    std::map<std::string, int, std::function<bool(const std::string&, const std::string&)>&gt; myMap(myCompare);</p><pre><code>// 其他操作...return 0;</code></pre><p>}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;a href=&quot;pic-洛谷字符串/12.斯诺登的密码.png&quot;&gt;alt text&lt;/a&gt;&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;include &quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>5. kotori和素因子（A组，B组）</title>
    <link href="http://example.com/posts/4c507725.html"/>
    <id>http://example.com/posts/4c507725.html</id>
    <published>2024-10-24T14:06:56.000Z</published>
    <updated>2024-11-18T14:04:26.224Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/5. kotori和素因子（A组，B组）.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/<em><br>思路总结：<br>1.保存1000以内的质数—埃拉托斯特尼筛法<br>2.求出所有整数的所有素因子—动态二维数组<br>3.dfs求出最小素因子之和</em>/<br>int ans = 9999999;<br>int n;<br>int vis[10001];</p><p>vector<int>v[100];<br>const int MAX = 1001;<br>bool prime[MAX];<br>// 埃拉托斯特尼筛法<br>void init(){<br>    fill(prime,prime + MAX,true); //初始化全为质数<br>    for(int i = 2 ; i <em> i &lt; MAX; ++i){<br>        if(prime[i]){<br>            for(int j = i </em> i; j &lt; MAX; j+=i){<br>                prime[j] = false;<br>            }<br>        }<br>    }<br>}<br>void dfs(int d,int sum){//重点<br>    if(d == n){//先写退出条件—深度达到最大值<br>        ans = min(ans,sum);<br>        return;<br>    }<br>    for(int i = 0; i &lt; v[d].size(); i++){//从最底层开始，一次选一个值<br>        if(!vis[v[d][i]]){<br>            vis[v[d][i]] = 1;//标记该值，表已经被用过<br>            dfs(d + 1, sum + v[d][i]); //选完一个换下一个<br>            vis[v[d][i]] = 0; //上一个选完后回头，换一个路，将之前标记过的值还原<br>        }<br>    }<br>}<br>int main(){<br>    init();<br>    scanf(“%d”,&amp;n);<br>    for(int i = 0; i &lt; n; i++){<br>        int temp;<br>        scanf(“%d”,&amp;temp);<br>        for(int j = 2; j &lt;= temp; j++){<br>            if(prime[j]&amp;&amp;temp % j == 0){<br>                v[i].push_back(j);<br>            }<br>        }<br>    }<br>    dfs(0,0);<br>    if(ans == 9999999) printf(“-1\n”);<br>    else printf(“%d\n”,ans);<br>    return 0;<br>} </p><p>c语言版</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <string.h></h1><p>int ans = 9999999;<br>int n;<br>int vis[10001];</p><p>int v[100][100];<br>const int MAX = 1001;<br>int prime[MAX];</p><p>void init() {<br>    memset(prime, 1, sizeof(prime)); // 初始化全为质数<br>    for (int i = 2; i <em> i &lt; MAX; ++i) {<br>        if (prime[i]) {<br>            for (int j = i </em> i; j &lt; MAX; j += i) {<br>                prime[j] = 0;<br>            }<br>        }<br>    }<br>}</p><p>void dfs(int d, int sum) {<br>    if (d == n) {<br>        ans = ans &lt; sum ? ans : sum;<br>        return;<br>    }<br>    for (int i = 0; i &lt; 100; i++) {<br>        if (v[d][i] != 0 &amp;&amp; !vis[v[d][i]]) {<br>            vis[v[d][i]] = 1;<br>            dfs(d + 1, sum + v[d][i]);<br>            vis[v[d][i]] = 0;<br>        }<br>    }<br>}</p><p>int main() {<br>    init();<br>    scanf(“%d”, &amp;n);<br>    for (int i = 0; i &lt; n; i++) {<br>        int temp;<br>        scanf(“%d”, &amp;temp);<br>        int k = 0;<br>        for (int j = 2; j &lt;= temp; j++) {<br>            if (prime[j] &amp;&amp; temp % j == 0) {<br>                v[i][k] = j;<br>                k++;<br>            }<br>        }<br>    }<br>    dfs(0, 0);<br>    if (ans == 9999999) printf(“-1\n”);<br>    else printf(“%d\n”, ans);<br>    return 0;<br>}<br>错误点：<br>c语言没有vector 但不一定非要知道数组的大小，设置一个足够大的数组范围，判断其元素值不为0即可停止 (因为数组有效元素不为0)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;pic-牛客/5. kotori和素因子（A组，B组）.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>10.单词覆盖还原</title>
    <link href="http://example.com/posts/0.html"/>
    <id>http://example.com/posts/0.html</id>
    <published>2024-10-23T07:07:13.945Z</published>
    <updated>2024-10-24T11:20:10.227Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>heo/source/_posts/洛谷-题单-字符串-代码/10.单词覆盖还原.md<br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    int numboy = 0,numgirl = 0;<br>    string s;<br>    cin&gt;&gt;s;</p><pre><code>for(int i = 0; i&lt;s.size();i++)&#123;    //cout&lt;&lt;&quot;i--&gt;&quot;&lt;&lt;i&lt;&lt;&quot; &quot;;    if(s[i] == &#39;b&#39;)&#123;        if(s[i + 1] == &#39;o&#39;)&#123;            if(s[i + 2] == &#39;y&#39;)&#123;                numboy++;                i = i+2;            //    cout&lt;&lt;endl&lt;&lt;&quot;boy&quot;&lt;&lt;endl;            &#125;            else&#123;                numboy++;                i = i+1;            //    cout&lt;&lt;endl&lt;&lt;&quot;bo&quot;&lt;&lt;endl;            &#125;        &#125;        else&#123;            //i++;            numboy++;        //    cout&lt;&lt;endl&lt;&lt;&quot;b&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;o&#39;)&#123;        if(s[i + 1] == &#39;y&#39;)&#123;            numboy++;            i = i+1;                //cout&lt;&lt;endl&lt;&lt;&quot;oy&quot;&lt;&lt;endl;        &#125;        else&#123;            //i++;            numboy++;            //cout&lt;&lt;endl&lt;&lt;&quot;o&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;y&#39;)&#123;        //cout&lt;&lt;endl&lt;&lt;i;        //i++;        numboy++;        //cout&lt;&lt;endl&lt;&lt;&quot;y&quot;&lt;&lt;endl;    &#125;    else if(s[i] == &#39;g&#39;)&#123;        if(s[i + 1] == &#39;i&#39;)&#123;            if(s[i + 2] == &#39;r&#39;)&#123;                if(s[i + 3] == &#39;l&#39;)&#123;                    numgirl++;                    i = i+3;                    //cout&lt;&lt;endl&lt;&lt;&quot;girl&quot;&lt;&lt;endl;                    //cout&lt;&lt;endl&lt;&lt;i;                &#125;                else&#123;                    numgirl++;                    i = i+2;                //    cout&lt;&lt;endl&lt;&lt;&quot;gir&quot;&lt;&lt;endl;                &#125;            &#125;            else&#123;                numgirl++;                i = i+1;                //cout&lt;&lt;endl&lt;&lt;&quot;gi&quot;&lt;&lt;endl;            &#125;        &#125;        else&#123;            numgirl++;            //cout&lt;&lt;endl&lt;&lt;&quot;g&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;i&#39;)&#123;        if(s[i + 1] == &#39;r&#39;)&#123;            if(s[i + 2] == &#39;l&#39;)&#123;                numgirl++;                i = i+2;                    //cout&lt;&lt;endl&lt;&lt;&quot;irl&quot;&lt;&lt;endl;            &#125;            else&#123;                numgirl++;                i = i+1;                    //cout&lt;&lt;&quot;ir&quot;&lt;&lt;endl;            &#125;        &#125;else&#123;            numgirl++;            //    cout&lt;&lt;endl&lt;&lt;&quot;i&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;r&#39;)&#123;        if(s[i + 1] == &#39;l&#39;)&#123;            numgirl++;            i = i+1;                //cout&lt;&lt;endl&lt;&lt;&quot;rl&quot;&lt;&lt;endl;        &#125;        else&#123;            numgirl++;            //cout&lt;&lt;endl&lt;&lt;&quot;r&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;l&#39;)&#123;        //i++;        numgirl++;        //cout&lt;&lt;endl&lt;&lt;&quot;l&quot;&lt;&lt;endl;    &#125;&#125;cout&lt;&lt;numboy&lt;&lt;endl&lt;&lt;numgirl;return 0;</code></pre><p>}<br>错误：if里面不能用break;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;heo/source/_posts/洛谷-题单-字符串-代码/10.单词覆盖还原.md&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;include &quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>9.小果的键盘</title>
    <link href="http://example.com/posts/2532b67f.html"/>
    <id>http://example.com/posts/2532b67f.html</id>
    <published>2024-10-22T14:06:56.000Z</published>
    <updated>2024-10-23T07:06:37.137Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="../练习题/牛客/pic-牛客/9.小果的键盘.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    int n;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    int num = 0;</p><pre><code>for(int i = 0;i &lt; s.size() - 1;i++)&#123;    if(s[i] == &#39;V&#39; &amp;&amp; s[i + 1] == &#39;K&#39;)&#123;        num++;        s[i] = s[i + 1] = 0;    &#125;&#125;int pos = s.find(&quot;VV&quot;);if(pos &gt;= 0)&#123;    num++;&#125;else&#123;    pos = s.find(&quot;KK&quot;);    if(pos &gt;= 0) num++;&#125;cout&lt;&lt;num;return 0;</code></pre><p>}<br>错误原因：<br>1.s.find(“VV”)<br>函数引用字符串用””,引用字符时用’’<br>2.s.size()<br>忘记写括号导致出错<br>3.利用最朴素的方法做，不出错超时在考虑其他方法，不要总想着用现成函数，容易出错<br>4.出错时学会改变条件<br>eg:最初想法是 删去VK后的字符串，若长度大于1，且V第一次出现的位置不在最后，说明不是‘KV’的情况，num+1 错误<br>    则改变“互补”条件：只要有“VV”,”KK”时num就+1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;../练习题/牛客/pic-牛客/9.小果的键盘.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>8.手机</title>
    <link href="http://example.com/posts/b114fdb0.html"/>
    <id>http://example.com/posts/b114fdb0.html</id>
    <published>2024-10-20T14:06:56.000Z</published>
    <updated>2024-10-23T07:06:37.134Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="pic-洛谷字符串/8.手机.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    string str;<br>    int num = 0;<br>    getline(cin,str);<br>    for(int i = 0; i &lt; str.size(); i++){<br>        if(str[i] == ‘a’ ||str[i] == ‘d’ ||str[i] == ‘g’ ||str[i] == ‘j’ ||str[i] == ‘m’ ||str[i] == ‘p’||str[i] == ‘t’ ||str[i] == ‘w’){<br>            num++;<br>        }<br>        else if(str[i] == ‘b’ ||str[i] == ‘e’ ||str[i] == ‘h’ ||str[i] == ‘k’ ||str[i] == ‘n’ ||str[i] == ‘q’ ||str[i] == ‘u’ ||str[i] == ‘x’){<br>            num = num + 2;<br>        }<br>        else if(str[i] == ‘c’ ||str[i] == ‘f’ ||str[i] == ‘i’ ||str[i] == ‘l’ ||str[i] == ‘o’ ||str[i] == ‘r’ ||str[i] == ‘v’ ||str[i] == ‘y’){<br>            num = num + 3;<br>        }<br>        else if(str[i] == ‘s’ || str[i] == ‘z’){<br>            num = num + 4;<br>        }<br>        else num++;<br>    }<br>    cout&lt;&lt;num;<br>    return 0;<br>}<br>更好的思路：</p><h1 id="include”iostream”"><a href="#include”iostream”" class="headerlink" title="include”iostream”"></a>include”iostream”</h1><h1 id="include”cstdio”"><a href="#include”cstdio”" class="headerlink" title="include”cstdio”"></a>include”cstdio”</h1><h1 id="include”cstring”-为用strchr查找函数"><a href="#include”cstring”-为用strchr查找函数" class="headerlink" title="include”cstring”//为用strchr查找函数"></a>include”cstring”//为用strchr查找函数</h1><p>using namespace std;<br>char s1[]={“ adgjmptw”},s2[]={“behknqux”},s3[]={“cfilorvy”},s4[]={“sz”};//可以望文生义，分别开按1~4次键盘的常量数组<br>int main()<br>{<br> char c;<br> int s=0;<br> while((c=getchar())!=EOF) //！=EOF表示还没输入结束<br>  {<br>  //在s1~s4中依次找，找到就加上1~4<br>   if(strchr(s1,c)) s++;<br>   else if(strchr(s2,c)) s+=2;<br>   else if(strchr(s3,c)) s+=3;<br>   else if(strchr(s4,c)) s+=4; //注意这里不能写成else，因为还会有\n等字符<br>  }<br> cout&lt;&lt;s&lt;&lt;endl;<br> r</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;pic-洛谷字符串/8.手机.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;include &quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>4.（A组，B组）</title>
    <link href="http://example.com/posts/c48970d5.html"/>
    <id>http://example.com/posts/c48970d5.html</id>
    <published>2024-10-20T14:06:56.000Z</published>
    <updated>2024-10-23T07:06:37.141Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/4.（A组，B组）.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    long long n,result = 0;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    int num[26] = {0},dp[26] = {0};<br>    for(int i = 0; i &lt; n;i++){<br>        result = result + dp[s[i] - ‘a’];<br>        dp[s[i] - ‘a’] += i - num[s[i] - ‘a’];<br>        num[s[i] - ‘a’]++;<br>    }<br>    cout&lt;&lt;result;<br>    return 0;<br>}<br>方法思想：动态规划<br>eg:abcbcc<br>判断“abb”式的大体思想是：第一个字符和第二个字符不同，第二个字符和第三个字符相同 == 每遍历一个字符“b”，判断在此之前有多少个“ab”<br>重难点:如何判断在此之前有多少个“ab”：用当前遍历的元素个数 - 该元素此前出现的次数 剩下的就是与该元素不同的元素，只要不同就能构成一个“ab”，能构成一个“ab”，该元素就能构成多少个“abb”<br>需要的变量：result存储结果，dp[26]存储构成的“ab”数量，num[26]存储不同字母出现的次数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目：&lt;br&gt;&lt;img src=&quot;pic-牛客/4.（A组，B组）.png&quot; alt=&quot;alt text&quot;&gt;&lt;br&gt;代码：&lt;/p&gt;
&lt;h1 id=&quot;include&quot;&gt;&lt;a href=&quot;#include&quot; class=&quot;headerlink&quot; title=&quot;include &quot;</summary>
      
    
    
    
    
  </entry>
  
</feed>
