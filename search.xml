<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>队列</title>
      <link href="/posts/b6c47025.html"/>
      <url>/posts/b6c47025.html</url>
      
        <content type="html"><![CDATA[<p>基于c++</p><p>队列核心思想： 先进先出</p><p>头文件：#include&lt; queue&gt;<br>1.定义及初始化：<br>queue<Type, Container> (&lt;数据类型，容器类型&gt;）<br>初始化时必须要有数据类型，容器可省略，省略时则默认为deque 类型<br>eg:<br>queue<int>q1;<br>queue<double>q2;<br>queue＜char＞q3；<br>//默认为用deque容器实现的queue；</p><p>queue＜char, list＜char＞＞q1；<br>//用list容器实现的queue </p><p>queue＜int, deque＜int＞＞q2；<br> //用deque容器实现的queue </p><p>2.queue常用函数<br>push() 在队尾插入一个元素<br>pop() 删除队列第一个元素<br>size() 返回队列中元素个数<br>empty() 如果队列空则返回true<br>front() 返回队列中的第一个元素<br>back() 返回队列中最后一个元素</p><p>eg:<br>1.push（）<br> queue <string> q;<br>    q.push(“first”);<br>    q.push(“second”);<br>    cout&lt;<q.front()<<endl; //输出 first2.pop() queue <string> q;<br>    q.push(“first”);<br>    q.push(“second”);<br>    q.pop();<br>    cout&lt;<q.front()<<endl;//输出 second 因为 first 已经被pop（）函数删掉了3.size()  queue <string> q;<br>       q.push(“first”);<br>       q.push(“second”);<br>       cout&lt;<q.size()<<endl;//输出2，因为队列中有两个元素4.empty()queue <string> q;<br>    cout&lt;<q.empty()<<endl;    q.push("first");    q.push("second");    cout<<q.empty()<<endl; //分别输出1和0    最开始队列为空，返回值为1（ture）；    插入两个元素后，队列不为空，返回值为0（false）；5.front() queue <string> q;<br>    q.push(“first”);<br>    q.push(“second”);<br>    cout&lt;<q.front()<<endl;    q.pop();    cout<<q.front()<<endl;//第一行输出first；    第二行输出second，因为pop（）已经将first删除了6.back() queue <string> q;<br>    q.push(“first”);<br>    q.push(“second”);<br>    cout&lt;&lt;q.back()&lt;&lt;endl;//输出最后一个元素second</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>补充知识</title>
      <link href="/posts/538de8cc.html"/>
      <url>/posts/538de8cc.html</url>
      
        <content type="html"><![CDATA[<p>1.卡特兰数<br>C0 = 1,<br>C1 = 1,         C2 = 2,          C3 = 5,          C4 = 14,          C5 = 42,<br>C6 = 132,       C7 = 429,        C8 = 1430<br>递推式1:<br>f[n]=f[0]∗f[n−1]+f[1]∗f[n−2]+…+f[n−1]∗f<a href="n≥2">0</a></p><p>递推式2：<br>h[n]=h[n−1]∗(4∗n−2)/(n+1)</p><p>递推式3：也叫组合数公式<br>h[n]=C[2n,n]/(n+1)(n=0,1,2,…),C是组合数<br>PS:C[m,n]=C[m−1,n−1]+C[m−1,n] 且规定：C[n,0]=1 C[n,n]=1 C[0,0]=1</p><p>递推式4：也叫组合数公式<br>h[n]=C[2n,n]−C<a href="n=0,1,2,...">2n,n−1</a> </p><p>应用：<br>‘3.1044 [NOIP2003 普及组] 栈’ 出栈的顺序个数</p><p>建立数组f。f[i]表示i个数的全部可能性。<br>f[0] = 1, f[1] = 1; //当然只有一个<br>设 x 为当前出栈序列的最后一个，则x有n种取值 （总共有n个数，每个数都有可能最后出栈）</p><p>由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分<br>比x小 比x大</p><p>比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]（因为入栈序列是1，2，3…n）<br>比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]</p><p>这两部分互相影响，所以一个x的取值能够得到的所有可能性为f[x-1] * f[n-x]<br>另外，由于x有n个取值，所以</p><p>ans = f[0]<em>f[n-1] + f[1]</em>f[n-2] + … + f[n-1]*f[0];</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1.查找文献</title>
      <link href="/posts/9dfe9002.html"/>
      <url>/posts/9dfe9002.html</url>
      
        <content type="html"><![CDATA[<p>题目：</p><h1 id="【深基18-例3】查找文献"><a href="#【深基18-例3】查找文献" class="headerlink" title="【深基18.例3】查找文献"></a>【深基18.例3】查找文献</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。</p><p>假设洛谷博客里面一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及 $m(m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。</p><p>这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f4n4tlhi.png" alt=""></p><p>请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 $m+1$ 行，第 1 行为 2 个数，$n$ 和 $m$，分别表示一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及$m(m\le10^6)$ 条参考文献引用关系。</p><p>接下来 $m$ 行，每行有两个整数 $X,Y$ 表示文章 X 有参考文献 Y。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 2 行。<br>第一行为 DFS 遍历结果，第二行为 BFS 遍历结果。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 7</span><br><span class="line">4 8</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 5 6 3 7 8 4 </span><br><span class="line">1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure><p>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>const int maxn = 100001;<br>int n,m;<br>vector<int>l[maxn]; //存入每篇文献的参考文献  假设已经排好序<br>bool vis[maxn];</p><p>int dfs(int step,int z){//z表示第z篇文献<br>    if(step == n) return 0;<br>    for(int i = 0; i &lt; l[z].size(); i++){<br>        if(vis[l[z][i]]){<br>            vis[l[z][i]] = false;<br>            cout&lt;<l[z][i]<<" ";            dfs(step+1,l[z][i]);        }    }    return 0;} int bfs(){    queue<int>q;<br>    for(int i = 0; i &lt; l[1].size(); i++){<br>        if(vis[l[1][i]]){<br>            q.push(l[1][i]);<br>            vis[l[1][i]] = false;<br>        }<br>    }<br>    while(!q.empty()){<br>        int temp = q.front();<br>        q.pop();<br>        cout&lt;<temp<<" ";        for(int i = 0; i < l[temp].size(); i++){            if(vis[l[temp][i]]){                q.push(l[temp][i]);                vis[l[temp][i]] = false;            }        }    }    return 0;}int main(){    cin>&gt;n&gt;&gt;m;<br>    for(int i = 0; i &lt; m; i++){<br>        int a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        l[a].push_back(b);//在第a篇文献后面加入参考文献 a下标从1开始<br>    }<br>    for(int i = 1; i &lt;= n; i++){<br>        sort(l[i].begin(),l[i].end());<br>    }<br>    for(int i = 0; i &lt;= n; i++){<br>        vis[i] = true;<br>    }<br>    vis[1] = false;//下标从1开始<br>    cout&lt;&lt;”1 “;<br>    dfs(0,1);</p><pre><code>cout&lt;&lt;endl;for(int i = 0; i &lt;= n; i++)&#123;     vis[i] = true;&#125;vis[1] = false;//下标从1开始 cout&lt;&lt;&quot;1 &quot;;bfs();return 0;</code></pre><p>}<br>知识点：<br>1.队列<br>2.BFS:一层一层遍历<br>3.邻接表：用vector动态数组来存储<br>错误：<br>DFS 没有写return</p><p>int dfs(int step,int z){//z表示第z篇文献<br>    if(step == n) return 0;<br>    for(int i = 0; i &lt; l[z].size(); i++){<br>        if(vis[l[z][i]]){<br>            vis[l[z][i]] = false;<br>            cout&lt;&lt;l[z][i]&lt;&lt;” “;<br>            dfs(step+1,l[z][i]);<br>        }<br>    }<br>    return 0;//遍历完最后要返回<br>} </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2.图的遍历</title>
      <link href="/posts/58e6b116.html"/>
      <url>/posts/58e6b116.html</url>
      
        <content type="html"><![CDATA[<p>题目：</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 $1$ 行 $2$ 个整数 $N,M$，表示点数和边数。</p><p>接下来 $M$ 行，每行 $2$ 个整数 $U_i,V_i$，表示边 $(U_i,V_i)$。点用 $1,2,\dots,N$ 编号。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行 $N$ 个整数 $A(1),A(2),\dots,A(N)$。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 4 3 4</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul><li>对于 $60\%$ 的数据，$1 \leq N,M \leq 10^3$。</li><li>对于 $100\%$ 的数据，$1 \leq N,M \leq 10^5$。</li></ul><p>代码：<br>$</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>const int maxn = 100001;<br>int m,n;<br>vector<int>l[maxn];<br>bool vis[maxn];<br>int result[maxn];<br>void dfs(int z,int a){<br>    vis[z] = true;//a表示一条路的最大值，将这条路上所有的点的结果全写为a<br>    result[z] = a;<br>    for(int i = 0; i &lt; l[z].size(); i++){<br>        if(!vis[l[z][i]]){<br>            dfs(l[z][i],a);<br>        }<br>    }<br>}<br>int main(){<br>    cin&gt;&gt;n&gt;&gt;m;<br>    for(int i = 0; i &lt; m; i++){<br>        int a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        l[b].push_back(a);<br>    }<br>    for(int i = n; i &gt;= 1; i—){<br>        if(!vis[i]){<br>            dfs(i,i);//确保遍历过每个点<br>        }<br>    }<br>    for(int i = 1; i &lt;= n; i++){<br>        cout&lt;&lt;result[i]&lt;&lt;” “;<br>    }<br>}<br>核心思想：倒着访问图</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5.Function</title>
      <link href="/posts/7199d339.html"/>
      <url>/posts/7199d339.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>对于一个递归函数w(a,b,c)<br>如果  a ≤ 0  或  b ≤ 0 或  c ≤ 0 就返回值 1。<br>如果  a &gt; 20 或  b &gt; 20 或  c &gt; 20  就返回  w(20,20,20)<br>如果  a &lt; b 并且  b &lt; c  就返回 w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)。<br>其它的情况就返回 w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)<br>这是个简单的递归函数，但实现起来可能会有些问题。当 a,b,c 均为 15 时，调用的次数将非常的多。你要想个办法才行。<br>注意：例如w(30,−1,0) 又满足条件 1 又满足条件 2，请按照最上面的条件来算，答案为 1。</p><p>输入格式<br>会有若干行。<br>并以 −1,−1,−1 结束。<br>输出格式<br>输出若干行，每一行格式：<br>w(a, b, c) = ans<br>eg:<br>输入<br>1 1 1<br>2 2 2<br>-1 -1 -1<br>输出<br>w(1, 1, 1) = 2<br>w(2, 2, 2) = 4</p><p>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><h1 id="define-ll-long-long"><a href="#define-ll-long-long" class="headerlink" title="define ll long long"></a>define ll long long</h1><p>using namespace std;</p><p>ll w[21][21][21],a,b,c;</p><p>ll dp(ll a,ll b, ll c){</p><pre><code>if(a&lt;=0 || b&lt;=0 || c&lt;=0) return 1;if(a&gt;20 || b&gt;20 || c&gt;20)&#123;    w[20][20][20] = dp(20,20,20);    return w[20][20][20];&#125; if(w[a][b][c]) return w[a][b][c];if(a&lt;b &amp;&amp; b&lt;c)&#123;    w[a][b][c] = dp(a,b,c-1)+dp(a,b-1,c-1)-dp(a,b-1,c);    return w[a][b][c];&#125;w[a][b][c] = dp(a-1,b,c)+dp(a-1,b-1,c)+dp(a-1,b,c-1)-dp(a-1,b-1,c-1);return w[a][b][c];</code></pre><p>}<br>int main(){<br>    for(int l = 0; ;l++){<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        if(a==-1 &amp;&amp; b==-1 &amp;&amp; c==-1) break;<br>        cout&lt;&lt;”w(“&lt;&lt;a&lt;&lt;”, “&lt;&lt;b&lt;&lt;”, “&lt;&lt;c&lt;&lt;”)”&lt;&lt;” = “&lt;&lt;dp(a,b,c)&lt;&lt;endl;<br>    }<br>}<br>核心思想:记忆化搜索</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>错误合集</title>
      <link href="/posts/36c606a9.html"/>
      <url>/posts/36c606a9.html</url>
      
        <content type="html"><![CDATA[<p>1.<br>undefined reference to `WinMain’<br>翻译：找不到main<br>原因：main拼写错误</p><p>2.初始化数组<br>错误：dp[1001] = 1；<br>原因：并非初始化所有数为1，只是让边界为1</p><p>错误：memset(dp, 1, sizeof(dp));<br>原因：并没有初始化所有数为1，因为memset是按照字节大小来初始化的，若机器字长为16位，初始化后相当于每个元素的值都为0001 0001 0001 0001（2进制），而并非1</p><p>纠正：所以初始化非零整数时，最好用循环</p><p>3.<br>[Error] expected initializer before numeric constant<br>错误：const int maxn  10001;没有写=<br>纠正：const int maxn = 10001;</p><p>4.<br>[Error] expected ‘)’ before ‘;’ token<br>[Error] expected ‘;’ before ‘)’ token<br>错误：dfs(step+1;l[z][i]);<br>纠正：dfs(step+1,l[z][i]);<br>应该用，而不是；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>04-数的计算</title>
      <link href="/posts/72992f12.html"/>
      <url>/posts/72992f12.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>给出正整数 n，要求按如下方式构造数列：<br>1.只有一个数 n 的数列是一个合法的数列。<br>2.在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。<br>请你求出，一共有多少个合法的数列。两个合法数列a,b不同当且仅当两数列长度不同或存在一个正整数i≤∣a∣,使得<br>a i !=b i<br>​输入格式<br>输入只有一行一个整数，表示 n。<br>输出格式<br>输出一行一个整数，表示合法的数列个数</p><p>代码：<br>//20</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>int n;<br>int dp[1001];</p><p>int dfs(int n){<br>    if(n == 1) {<br>        return dp[n];<br>    }<br>    if(dp[n] &gt; 1) {<br>        return dp[n];<br>    }<br>    for(int i = 1; i &lt;= n/2; i++){<br>        dp[n] += dfs(i);<br>    }<br>    return dp[n];<br>}</p><p>int main(){<br>    cin&gt;&gt;n;<br>    for(int i = 0; i &lt;= n; i++){<br>        dp[i] = 1;<br>    }<br>    cout&lt;&lt;dfs(n);<br>    return 0;<br>}<br>递归式：f[i]=f[1]+f[2]+f[3]+…+f[i/2]+1</p><p>分析以及优化：<br>eg: n = 6<br>1&gt;计算f(6) 未被计算 进入循环<br>2&gt;计算f(1) 到达最底层 计算 退出循环<br>3&gt;计算f(2) 未被计算 进入循环<br>    3.1&gt;计算f(1) 到达最底层 计算 退出循环<br>4&gt;计算f(3) 未被计算 进入循环<br>    4.1&gt;计算f(1)到达最底层 计算 退出循环<br>现象：f(1)被重复遍历 虽然并未进行计算，但多次遍历仍然耗费时间<br>整体上看：遍历了三遍f(1) 返回计算f(2) f(3) f(6)</p><p>优化：空间换时间<br>递推公式可以优化为：<br>f(n)=SUM(n/2)+1,SUM(i)=SUM(i−1)+f(i)<br>代码：</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>int f[1005], sum[505];</p><p>int F(int i); int Sum(int i);</p><p>int main(){<br>    int n; cin&gt;&gt;n;<br>    f[1] = sum[1] = 1;<br>    cout&lt;&lt;F(n);<br>}</p><p>int F(int i){<br>    if(f[i]) return f[i]; //剪枝<br>    return f[i] = Sum(i/2) + 1;  //利用赋值，记忆<br>}</p><p>int Sum(int i){<br>    if(sum[i]) return sum[i]; //剪枝<br>    return sum[i] = Sum(i - 1) + F(i);  //利用赋值，记忆<br>}<br>未优化的代码只记忆了每个数的序列数量<br>而优化后的代码 一个数组记忆每个数的序列数量 一个数组记忆前2/n个数序列的和<br>这样每次计算，不用再求f[1]+f[2]+f[3]+…+f[i/2]<br>只需要求f(n)=SUM(n/2)+1</p><p>eg: n = 6<br>1.计算f(6) 未定义 计算sum(3) + 1<br>    1.1计算sum(3) sum(3) = sum(2) + f(2)<br>        1.1.1计算sum(2) sum(2) = sum(1) + f(1)    并列 计算f(2) f(2) = sum(1) + 1<br>            1.1.1.1计算sum(1) 已被定义 返回        并列 计算f(1) 已被定义 返回<br>整体上看 只遍历了一遍f(1) sum(1) 返回计算sum(2) f(2) 再返回计算sum(3)</p><p>继续优化—“就地” 在原地修改数据结构或数组，而不使用额外的空间来存储中间结果<br>f(n)=SUM(n/2)+1,SUM(i)=SUM(i−1)+f(i) 相当于只存储最后计算的f(n)的结果，自下而上计算，每向上以及就覆盖一次原值</p><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>int f, sum[505];</p><p>int main(){<br>    int n; cin&gt;&gt;n;<br>    for(int i = 1; i &lt;= n/2; i++){<br>        f = sum[i/2] + 1;<br>        sum[i] = f + sum[i - 1];<br>    }<br>    cout&lt;&lt; sum[n/2] + 1;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02-记忆搜索</title>
      <link href="/posts/a01a576c.html"/>
      <url>/posts/a01a576c.html</url>
      
        <content type="html"><![CDATA[<p>算法思想：<br>通过存储已经遍历过的状态信息，从而避免对同一状态重复遍历的搜索算法<br>即要求所有状态的目标值都是固定的，不随外在因素而变化，例如斐波那契数列</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3.1044 [NOIP2003 普及组] 栈</title>
      <link href="/posts/e5e77f5b.html"/>
      <url>/posts/e5e77f5b.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>输入格式<br>输入文件只含一个整数n（1≤n≤18）。</p><p>输出格式<br>输出文件只有一行，即可能输出序列的总数目(类似栈先进先出)。</p><p>错误思路：从序列中找规律<br>n = 1 ,1进1出 一种序列<br>n = 2, 1进1出，2进2出 和 1进2进，2出1出，两种序列<br>n = 3，123-&gt;123 213 231 132 321<br>n = 4, 1234-&gt;4321,</p><p>正确思路：<br>题目本质：栈内个数和栈外个数的动态变化 每种变化都有一个固定的值<br>例如：栈内有一个数，栈外有一个数的情况：<br>要么栈内的数出去-&gt;栈内0个数，栈外一个数<br>要么栈外的数入栈-&gt;栈内2个数，栈外一个数<br>和栈内栈外的数是几没有关系</p><p>dp思路：<br>设dp[i][j] i表示栈内元素个数，j表示栈外元素个数<br>最优子结构：[i-1][j] [i+1][j-1]<br>边界：栈外没有元素时，无论栈内几个元素，出栈顺序都为一种，即j = 0, dp[i][0] = 1<br>状态转化方程：dp[i][j] = dp[i-1][j] + dp[i+1][j-1]</p><p>代码：<br>法一：动态规划 dp 记忆搜索</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>long long dp[25][25];//存储不同情况的状态（出栈序列数量） </p><p>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    //边界 栈外没有元素的情况<br>    for(int i = 0; i &lt;= n; i++){ //存在栈内外没有元素的情况，n个数有n+1种情况<br>        dp[i][0] = 1;<br>    }<br>    for(int j = 1; j &lt;= n; j++){ //从栈外有一个元素开始讨论<br>        for(int i = 0; i &lt;= n; i++){<br>            if(i == 0){ //栈内没有元素，只能入栈<br>                dp[i][j] = dp[i+1][j-1];<br>            }<br>            else{<br>                dp[i][j] = dp[i+1][j-1] + dp[i-1][j];<br>            }<br>        }<br>    }<br>    cout&lt;&lt;dp[0][n];<br>}</p><p>法二 dfs 递归<br>代码：</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>long long dp[25][25];<br>int n;</p><p>long long dfs(int k,int n){//栈内0 栈外n<br>    if(dp[k][n]){<br>        return dp[k][n];<br>    }<br>    if(n == 0){//栈外没有元素<br>        return 1;<br>    }<br>    if(k == 0){//栈内没有元素<br>        return  dfs(k+1,n-1);<br>    }<br>    return dfs(k+1,n-1) + dfs(k-1,n);</p><p>}</p><p>int main(){<br>    cin&gt;&gt;n;<br>    cout&lt;&lt;dfs(0,n);//栈内0 栈外n<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>01-dp</title>
      <link href="/posts/c1f74d24.html"/>
      <url>/posts/c1f74d24.html</url>
      
        <content type="html"><![CDATA[<p>思想：拆分子问题，记住过往，减少重复计算。</p><p>典型特征：<br>最优子结构、状态转移方程、边界、重叠子问题<br>eg：<br>f(n-1)和f(n-2) 称为 f(n) 的最优子结构<br>f(n)= f（n-1）+f（n-2）就称为状态转移方程<br>f(1) = 1, f(2) = 2 就是边界<br>比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。</p><p>解题思路：<br>穷举分析<br>确定边界<br>找出规律，确定最优子结构<br>写出状态转移方程</p><p>1.穷举分析<br>拆分子问题：通过固定的方法如何得到目标<br>eg：<br>当台阶数是1的时候，有一种跳法，f（1） =1<br>当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;<br>当台阶是3级时，想跳到第3级台阶，要么是先跳到第2级，然后再跳1级台阶上去，要么是先跳到第 1级，然后一次迈 2 级台阶上去。所以f(3) = f(2) + f(1) =3<br>当台阶是4级时，想跳到第3级台阶，要么是先跳到第3级，然后再跳1级台阶上去，要么是先跳到第 2级，然后一次迈 2 级台阶上去。所以f(4) = f(3) + f(2) =5<br>当台阶是5级时……</p><p>2.确定边界<br>当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n&gt;=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。</p><p>3.找规律，确定最优子结构<br>n&gt;=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。</p><p>4.写出状态转移方程<br>f(n) = 1;n = 1<br>f(n) = 2;n = 2<br>f(n) = f(n - 1)f(n - 2); n &gt;= 3</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2.过河卒</title>
      <link href="/posts/1344076c.html"/>
      <url>/posts/1344076c.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。<br>棋盘用坐标表示，A 点 (0,0),B 点 (n,m)，同样马的位置坐标是需要给出的。<br>现在要求你计算出卒从 A 点能够到达 B 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。<br>输入格式<br>一行四个正整数，分别表示 B 点坐标和马的坐标。<br>输出格式<br>一个整数，表示所有的路径条数。<br><img src="pic/2.过河卒.png" alt="alt text"></p><p>dp思路<br>设当前点为（i，j）<br>最优子结构：(i-1,j) (i,j-1)两种路径可以到达<br>状态转移方程：（i，j） = (i-1,j)或(i,j-1)<br>边界 ：B 点 (n,m)，以及特殊情况马的范围</p><p>//01</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/<em><br>1.标记马的范围<br>2.遍历点 </em>/<br>bool vis[25][25];<br>long long dp[25][25];<br>int main(){<br>    int n,m,x,y;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y;<br>    n++;<br>    m++;<br>    x++;<br>    y++;<br>    vis[x][y] = 1;<br>    vis[x-2][y-1]=1;<br>    vis[x-2][y+1]=1;<br>    vis[x+2][y-1]=1;<br>    vis[x+2][y+1]=1;<br>    vis[x-1][y+2]=1;<br>    vis[x-1][y-2]=1;<br>    vis[x+1][y+2]=1;<br>    vis[x+1][y-2]=1;</p><pre><code>dp[0][1] = 1;for(int i = 1; i &lt;= n; i++)&#123;    for(int j = 1; j &lt;= m; j++)&#123;        if(!vis[i][j])&#123;            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];        &#125;    &#125;&#125;cout&lt;&lt;dp[n][m];</code></pre><p>} </p><p>题目本质：<br>求一点到另一条点在一些限制下总共有多少条路径<br>数学方法：标数法<br>相当于 走到该点的路径数量等于该点的上边点和右边点的标数和，和即为该点的标数<br>具体详见<br><a href="https://zhuanlan.zhihu.com/p/110868668">https://zhuanlan.zhihu.com/p/110868668</a></p><p>dp思想：<br>用vis[][]来当作遍历时的限制<br>dp[][]作为中间结果，直至到遍历到目标</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2.小鱼的数字游戏</title>
      <link href="/posts/c597fda3.html"/>
      <url>/posts/c597fda3.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>输入格式<br>一行内输入一串整数，以 0 结束，以空格间隔。<br>输出格式<br>一行内倒着输出这一串整数，以空格间隔。<br>代码：<br>//18</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>int main(){<br>    int a[101];<br>    int i = 0;<br>    do{<br>        cin&gt;&gt;a[i];<br>        i++;<br>    }while(a[i - 1] != 0);</p><pre><code>//倒着输出for(int j = i - 2; j &gt;= 0; j--)&#123;    cout&lt;&lt;a[j]&lt;&lt;&quot; &quot;;&#125;</code></pre><p>}<br>知识点：<br>do{…}while() 翻译 = 做某件事，当满足括号里的条件时</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1.数楼梯</title>
      <link href="/posts/8587ce5c.html"/>
      <url>/posts/8587ce5c.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>楼梯有 N 阶，上楼可以一步上一阶，也可以一步上二阶。<br>编一个程序，计算共有多少种不同的走法。<br>输入格式 一个数字，楼梯数。<br>输出格式 输出走的方式总数。<br>输入输出样例<br>4       5</p><p>代码：<br>//36</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>int main(){<br>    //输入楼梯数量<br>    int n;<br>    scanf(“%d”,&amp;n);</p><pre><code>//特殊情况if(n == 1 || n == 2 ||n == 0)&#123;    cout&lt;&lt;n;    return 0;&#125; //计算方法数量 高精度加法 存储在string 转为int[] 相加到int[]去前导零 dp1变为dp1,之和变为dp1 string dp0 = &quot;1&quot;;string dp1 = &quot;2&quot;;for(int i = 2; i &lt; n; i++)&#123;    int a[5005] = &#123;0&#125;,b[5005] = &#123;0&#125;;    int temp[5005] = &#123;0&#125;;    for(int j = 0; j &lt; dp0.size(); j++)&#123;        a[dp0.size() - 1 - j] = dp0[j] - &#39;0&#39;;    &#125;    for(int j = 0; j &lt; dp1.size(); j++)&#123;        b[dp1.size() - 1 - j] = dp1[j] - &#39;0&#39;;    &#125;    int max = dp0.size() &gt; dp1.size() ? dp0.size() : dp1.size();    for(int j = 0; j &lt; max; j++)&#123;        temp[j] += a[j] + b[j];        temp[j + 1] = temp[j] / 10 ;        temp[j] = temp[j] % 10;    &#125;    if(temp[max] &gt; 0)&#123;        max++;    &#125;    dp0 = dp1;    dp1 = &quot;&quot;;    for(int j = max - 1; j &gt;= 0; j--)&#123;        dp1 += to_string(temp[j]);    &#125;&#125;cout&lt;&lt;dp1;</code></pre><p>}<br>错误点：<br>1.字符串初始化 用”” 而不是’’<br>2.字符串转数字 dp1 += to_string(temp[j]);<br>    错误写法: dp1[j] = to_string(temp[j]);错误原因：不能将string类型转为char类型<br>    to_string赋值的对象是字符串，而dp1[j]具体成了一个char类型的字符<br>3.题目数值范围未搞清楚 超出long long 范围 -2^63~2^63-1后就要进行高精度加法运算 long(int) -2^31~2^31-1<br>    1&gt;两个加数长度位置，用字符串类型存储<br>    2&gt;将加数逆序转换为数值存入数组<br>    3&gt;进行相加，存入整型数组（仍为逆序），注意最高位是否产生进位，若是，则数组长度要加一<br>        int a[5005] = {0},b[5005] = {0};<br>        int temp[5005] = {0};<br>        for(int j = 0; j &lt; dp0.size(); j++){<br>            a[dp0.size() - 1 - j] = dp0[j] - ‘0’;<br>        }<br>        for(int j = 0; j &lt; dp1.size(); j++){<br>            b[dp1.size() - 1 - j] = dp1[j] - ‘0’;<br>        }<br>        int max = dp0.size() &gt; dp1.size() ? dp0.size() : dp1.size();<br>        for(int j = 0; j &lt; max; j++){<br>            temp[j] += a[j] + b[j];<br>            temp[j + 1] = temp[j] / 10 ;<br>            temp[j] = temp[j] % 10;<br>        }<br>        if(temp[max] &gt; 0){<br>            max++;<br>        }<br>解题思路：<br>相当于动态规划 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1.小鱼比可爱</title>
      <link href="/posts/ad1413b6.html"/>
      <url>/posts/ad1413b6.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。<br>输入格式：<br>第一行输入一个正整数n，表示鱼的数目。</p><p>第二行内输入 n个正整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度 </p><p>输入输出样例<br>6                   输出 0 0 0 3 1 2<br>4 3 0 5 1 2   </p><p>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <stdio.h></h1><p>int main(){<br>    int n;<br>    scanf(“%d”,&amp;n);<br>    int nums[n];<br>    int result[n];<br>    for(int i = 0; i &lt; n; i++){<br>        scanf(“%d”,&amp;nums[i]);<br>        int temp = 0;<br>        for(int j = 0; j &lt; i; j++){<br>            if(nums[i] &gt; nums[j]){<br>                temp++;<br>            }<br>        }<br>        result[i] = temp;<br>    }<br>    for(int i = 0; i &lt; n; i++){<br>        printf(“%d “,result[i]);<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>15.垂直柱状图</title>
      <link href="/posts/71fcaa9a.html"/>
      <url>/posts/71fcaa9a.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-洛谷字符串/15.垂直柱状图.png" alt="alt text"><br>题目：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/<em>44</em>/<br>int amount(int nums[],string s){<br>    /<em>for(long i = 0; i &lt; s.size();i++){ //这种方式会报错<br>        nums[s[i] - ‘A’]++;<br>    }</em>/</p><pre><code>for(long i=0;i&lt;s.length();i++)&#123; //这种不会    for(int j=0;j&lt;26;j++)&#123;        if(s[i]-65==j)&#123;            nums[j]++;        &#125;    &#125;&#125;return *nums; //!注意返回数组时在数组名前面加*</code></pre><p>}<br>int main(){<br>    //读入四行字符串<br>    string s1,s2,s3,s4;<br>    getline(cin,s1);<br>    getline(cin,s2);<br>    getline(cin,s3);<br>    getline(cin,s4);</p><pre><code>//统计字母数量int nums[26] = &#123;0&#125;;amount(nums,s1);amount(nums,s2);amount(nums,s3);amount(nums,s4);//输出int max = 0;for(int i = 0; i &lt; 26; i++)&#123;    max = max &gt; nums[i] ? max : nums[i];&#125;for(int i = max; i &gt; 0; i--)&#123;    for(int j = 0; j &lt; 26; j++)&#123;        if(nums[j] &gt;= i)&#123;            printf(&quot;* &quot;);            nums[j]--;        &#125;        else&#123;            printf(&quot;  &quot;);        &#125;    &#125;    printf(&quot;\n&quot;);&#125;cout&lt;&lt;&quot;A B C D E F G H I J K L M N O P Q R S T U V W X Y Z&quot;;return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6.红和蓝</title>
      <link href="/posts/a7aa720.html"/>
      <url>/posts/a7aa720.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/6.红和蓝.png" alt="alt text"><br>代码：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>14.语句解析</title>
      <link href="/posts/13921496.html"/>
      <url>/posts/13921496.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-洛谷字符串/14.语句解析.png" alt="alt text"><br>代码：<br>c++</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/*</p><p>*/<br>int main(){<br>    string s;<br>    getline(cin,s);<br>    map<char,string>q;<br>    q[‘a’] = ‘0’;<br>    q[‘b’] = ‘0’;<br>    q[‘c’] = ‘0’;<br>    for(int i = 0; i <s.size(); i++){        if(s[i] == '='){            if(s[i + 1] < '0' || s[i + 1] > ‘9’){//如果赋值的是变量 a:=b<br>                q[s[i - 2]] = q[s[i + 1]];<br>            }<br>            else{<br>                q[s[i - 2]] = s[i + 1];<br>            }<br>        }<br>    }<br>    cout&lt;&lt;q[‘a’]&lt;&lt;” “&lt;&lt;q[‘b’]&lt;&lt;” “&lt;&lt;q[‘c’]&lt;&lt;endl;</p><pre><code>return 0;</code></pre><p>}<br>法二：</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<cstdio></h1><p>using namespace std;<br>int a[3];char s1,s2;<br>int main()<br>{<br>    while (scanf(“%c:=%c;”,&amp;s1,&amp;s2)==2)//<br>     a[s1-‘a’]=s2&gt;=’0’ &amp;&amp; s2&lt;=’9’ ? s2-‘0’ : a[s2-‘a’]; //赋值语句简洁明了<br>    printf(“%d %d %d”,a[0],a[1],a[2]);<br>}</p><p>c语言</p><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <string.h></h1><p>int main(){<br>    int a[3] = {0};<br>    char s1,s2;<br>    while(scanf(“%c:=%c;”,&amp;s1,&amp;s2) == 2){<br>        a[s1 - ‘a’] = s2 &gt;= ‘0’ &amp;&amp; s2 &lt;= ‘9’ ? s2 - ‘0’ : a[s2 - ‘a’];<br>    }<br>    printf(“%d %d %d”,a[0],a[1],a[2]);<br>    return 0;<br>}</p><p>知识点：<br>1.scanf(“%c:=%c;”,&amp;s1,&amp;s2)==2</p><p>这行代码的格式字符串 “%c:=%c;” 包含以下几个部分：</p><p>%c：这是一个格式说明符，告诉 scanf 读取一个字符并将其存储在提供的地址（&amp;s1）。</p><p>:=：这是普通的字符，scanf 会从输入中读取这两个字符，但不会将它们存储在任何地方。它们在这里的作用是确保输入中包含这两个字符。</p><p>%c：这是另一个格式说明符，告诉 scanf 读取一个字符并将其存储在提供的地址（&amp;s2）。</p><p>;：这是普通的字符，scanf 会从输入中读取这个字符，但不会将其存储在任何地方。它在这里的作用是确保输入以分号结束。</p><p>scanf 函数返回成功匹配的输入项的数量。在这个例子中，格式字符串期望两个字符（由 %c 指定），所以如果输入正确，scanf 应该返回 2。这个返回值然后与 2 进行比较，以确保两个字符都已成功读取。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>13.你的飞碟在这儿 Your Ride Is Here</title>
      <link href="/posts/777cdf84.html"/>
      <url>/posts/777cdf84.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><a href="13.你的飞碟在这儿 Your Ride Is Here.md">text</a><br>代码：<br>c++</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>int data(string s){<br>    int num = 1;<br>    for(int i = 0; i &lt; s.size(); i++){<br>        num = num * (s[i] - ‘A’ + 1);<br>    }<br>    return num;<br>}</p><p>int main(){<br>    string s1;<br>    string s2;<br>    cin&gt;&gt;s1&gt;&gt;s2;</p><pre><code>int num1 = data(s1);//彗星 int num2 = data(s2);//小组 if(num2 % 47 == num1 %47)&#123;    cout&lt;&lt;&quot;GO&quot;;&#125;else cout&lt;&lt;&quot;STAY&quot;;return 0;</code></pre><p>}</p><p>c</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <stdlib.h></h1><p>int data(char s[]){<br>    int num = 1;<br>    for(int i = 0; s[i] != ‘\0’; i++){ //知识点2<br>        num = num * (s[i] - ‘A’ + 1);<br>    }<br>    return num;<br>}</p><p>int main(){<br>    char s1[100];  //知识点1<br>    char s2[100];</p><pre><code>scanf(&quot;%s %s&quot;,s1,s2);int num1 = data(s1);int num2 = data(s2);if(num2 % 47 == num1 % 47)&#123;    printf(&quot;GO&quot;);&#125;else printf(&quot;STAY&quot;);return 0;</code></pre><p>}</p><p>知识点：</p><ol><li>c语言 虽然char a[] 每个元素只能存储一个字符，但是可以多位输入<br>2.for(int i = 0; s[i] != ‘\0’; i++) 遍历char数组，用’\0’来判断结束</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>03-埃拉托斯特尼筛法</title>
      <link href="/posts/7a2fccc2.html"/>
      <url>/posts/7a2fccc2.html</url>
      
        <content type="html"><![CDATA[<p>埃拉托斯特尼筛法（Sieve of Eratosthenes）:<br>1.目的：用于找出一定范围内所有质数的算法<br>2.基本思想：从小到大逐个筛选数，将合数（非质数）标记掉，最终剩下的即为质数。<br>3.详细解释：</p><p>1&gt;初始化：<br>创建一个长度为n+1的布尔数组（通常称为isPrime或prime），初始值全部设置为true，表示所有数都是质数。<br>筛选过程：</p><p>2&gt;从2开始，将第一个质数2标记为质数（true），然后将2的所有倍数标记为非质数（false）。<br>然后找到下一个未被标记的数，即下一个质数3，将其标记为质数，然后将3的所有倍数标记为非质数。<br>依次类推，直到遍历完所有小于等于n的数。</p><p>3&gt;筛选规则：<br>对于每个质数p，将其所有大于等于p^2且小于等于n的倍数标记为非质数。<br>这是因为：<br>1.如果一个数 x 是质数 p 的倍数，并且 x &lt; p <em> p，那么 x 可以表示为 x = p </em> k，其中 k 是一个小于 p 的数。<br>2.在之前处理质数 k 时，已经标记过 k 的所有倍数，包括 p <em> k。<br>3.因此，p </em> k 已经在处理 k 时被标记为非质数，而且 k &lt; p，所以 p <em> k &lt; p </em> p。<br>4.因此，在处理质数 p 时，小于 p <em> p 的 p 的倍数已经被标记过了，不需要再次标记。<br>eg: i = 2 标记 4 6 8…<br>    i = 3 从9开始 因为 2</em>3 = 6 在遍历2的时候就已经遍历了<br>    换言之，一个数的因子，除了根号外 一定一个大一个小，在求倍数的时候，从小的开始遍历，再到大的时候就标记从以这个数作为小因数开始的倍数即可</p><p>4&gt;结果提取：<br>最终留下的isPrime[i]为true的数i即为质数。</p><p>4.复杂度：<br>埃拉托斯特尼筛法的时间复杂度为O(n log log n)，其中n为要筛选的范围内的数的个数。</p><p>这种算法的优点在于简单易懂，且在一定范围内找质数的效率很高。然而，对于大范围内的质数筛选，其他更高效的算法可能更合适。</p><p>代码：<br>const int MAX = 1000005;<br>bool prime[MAX];<br>void init() {<br>    memset(prime,true,sizeof prime); //知识点<br>    for(int i=2; i<em>i&lt;MAX; i++) { //目的是标记倍数，当以i为小因数开始的倍数以及大于范围时，就没有标记的范围了 换言之，i就是最大的因数<br>        if(prime[i]) {//是素数<br>            for(int j=i</em>2; j&lt;MAX; j+=i)//从2倍开始，n倍<br>                prime[j]=false;//各个倍数<br>        }<br>    }<br>}</p><p>解释：为什么i*i&lt;MAX;<br>在埃拉托斯特尼筛法中，当我们处理质数 p 时，我们只需要标记 p 的倍数，其中 p 的平方小于或等于 n。这是因为如果 p 的平方大于 n，那么 p 的倍数已经超出了我们要筛选的范围，不需要再标记这些倍数。</p><p>举个例子：</p><p>假设我们要找出小于等于 30 的所有质数：</p><p>当处理质数 2 时，我们从 2 的平方开始标记倍数，即从 4 开始。因为 2 的平方是 4，小于等于 30，所以我们需要标记 2 的倍数。<br>当处理质数 3 时，我们从 3 的平方开始标记倍数，即从 9 开始。因为 3 的平方是 9，小于等于 30，所以我们需要标记 3 的倍数。<br>当处理质数 5 时，我们从 5 的平方开始标记倍数，即从 25 开始。因为 5 的平方是 25，小于等于 30，所以我们需要标记 5 的倍数。<br>如果我们考虑一个更大的质数，比如 7，7 的平方是 49，大于 30，这意味着 7 的倍数已经超出了我们要筛选的范围，因此不需要再标记 7 的倍数。<br>因此，为了确保我们在筛选范围内正确地标记质数的倍数，我们需要保证 p 的平方小于或等于我们要筛选的最大值 n。</p><p>知识点：<br>一.memset()函数<br>1.作用：用于将一块内存空间的每个字节都设置为指定的值<br>2.用法：memset(初始地址,要设的值,类型长度) eg:memset(prime,true,sizeof prime);</p><p>注意点：在C++中，memset函数经常用来初始化整型数组、字符数组或其他基本数据类型的数组。但对于非整型数据类型，如bool类型，使用memset可能会导致一些问题，因为bool类型在C++中并不是一个字节大小的数据类型，而是一个字节中的某一位。因此，对于bool类型数组，最好使用循环或其他方法显式地设置每个元素的值。<br>3.头文件：<cstring></p><p>扩展：std::fill 函数<br>1.作用：是 C++ 标准库中的一个函数模板，它用于将指定的值赋给一个容器或数组的特定范围内的所有元素<br>2.头文件：<algorith><br>3.用法：<br>eg:vector<int> vec(5);<br>    fill(vec.begin(), vec.end(), -1); // 将 vector 中的每个元素都设置为 -1</p><p>fill()函数和memset()函数的区别<br>1.std::fill<br>是 C++ 标准库中的一个模板函数，定义在 <algorithm> 头文件中。<br>可以用于任何类型的容器，包括数组、std::vector、std::list、std::array 等。<br>可以填充任何类型的值，不仅仅是字节值。<br>需要两个迭代器参数来指定要填充的元素范围。<br>安全性更高，因为它基于类型，编译器会检查类型匹配，减少类型错误的风险。<br>2.memset<br>是 C 语言标准库中的一个函数，定义在 <cstring> 头文件中。<br>通常用于填充字节序列，适用于简单的数据类型（如 char、unsigned char 等）。<br>不能用于填充复杂数据类型，因为它只处理字节级别的赋值。<br>只需要一个指针参数指向要填充的内存块的开始位置，以及要设置的值和要填充的字节数。<br>效率可能更高，因为它直接操作内存，不涉及迭代器的解引用和递增操作。</p><p>二.i++和++i的区别<br>++i：返回 i 增加 1 后的值<br>i++：返回 i 增加 1 之前的值<br>eg:<br>i  = 1;<br>int a = ++i;  // i 现在是 2，a 是 2</p><p>i  = 1;<br>int b = i++;  // i 现在是 2，但 b 是 1</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>03-DFS算法</title>
      <link href="/posts/1c45da2f.html"/>
      <url>/posts/1c45da2f.html</url>
      
        <content type="html"><![CDATA[<p>引入：<br>递归代码模板：<br>1.先写出口<br>2.再写普通相同情况<br>eg: 斐波那契数列 1 2 5 8 13…<br>int fibo(int a){<br>    if(a == 0 || a == 1){  //先写出口<br>        return 1;<br>    }<br>    else{<br>        return fibo(a - 1) + fibo( a - 2);<br>    }<br>}<br>思考是否具有递归特性：<br>1&gt;思考普遍情况<br>1.当为极端情况时(自下而上 最”下”的情况)的情况 eg:跳台阶，只有一个台阶<br>2.当为极端条件 + 1 时的情况 eg:跳台阶，有两个台阶</p><ol><li>…<br>2&gt;<br>推及到n时，(n - 1)对n的情况，是否只要知道了(n - 1),或(n - 2)等等以此类推 就能根据普遍情况得到n</li></ol><p>换言之，即 想要得到n的结果，是否需要得到(n - 1/2/3/..)的结果</p><p>DFS—深度优先算法<br>大概思路：不撞南墙不回头 依次走完所有路<br>eg：</p><ol><li>kotori和素因子（A组，B组）<br>void dfs(int d,int sum){//重点<br> if(d == n){//先写退出条件—深度达到最大值<pre><code> ans = min(ans,sum); return;</code></pre> }<br> for(int i = 0; i &lt; v[d].size(); i++){//从最底层开始，一次选一个值<pre><code> if(!vis[v[d][i]])&#123;     vis[v[d][i]] = 1;//标记该值，表已经被用过     dfs(d + 1, sum + v[d][i]); //选完一个换下一个     vis[v[d][i]] = 0; //上一个选完后回头，换一个路，将之前标记过的值还原 &#125;</code></pre> }<br>}</li></ol><p>简单想法：<br>画树状图<br>最底层即为出口 返回的是具体值<br>其余的都是从上返回下面的递归式<br>long long dfs(int k,int n){//栈内0 栈外n<br>    if(dp[k][n]){<br>        return dp[k][n];<br>    }<br>    if(n == 0){//栈外没有元素 值为1 出口<br>        return 1;<br>    }<br>    if(k == 0){//栈内没有元素<br>        return  dfs(k+1,n-1);<br>    }<br>    return dfs(k+1,n-1) + dfs(k-1,n);</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>02-KMP算法</title>
      <link href="/posts/777cdf84.html"/>
      <url>/posts/777cdf84.html</url>
      
        <content type="html"><![CDATA[<p>目的：在一个字符串中找一个字串<br>朴素暴力解法：<br>在主串中挨个找，匹配返回位置，不匹配回到下一个位置<br>问题：例如前面以及匹配过ab的组合，子串中也有ab,那么可以直接比较子串ab后面的字符和主串ab后面的字符,否则在挨个比较就重复了<br>故而提出<br>KMP算法：<br>1.需要得到前缀表 next[]数组<br>eg:设子串T=“aabaaf”，求T的前缀表 即next数组<br>1&gt;第一个子串 t0=“a”，没有前缀也没有后缀 next[0]=0<br>2&gt;第二个子串 t1=“aa”，前缀为”a”，后缀也为”a” next[1]=1<br>3&gt;第三个子串 t2=“aab”，该子串后缀中一定会有”b”，前缀中一定不含有”b”，没有相等的前后缀 next[2]=0<br>4&gt;第四个子串 t3=“aaba”，最大相等前后缀为”a”，长度为1，next[3]=1<br>5&gt;第五个子串 t4=“aabaa”，最大相等前后缀为”aa”，长度为2，next[4]=2<br>6&gt;第六个子串是t5=“aabaaf”，该子串的后缀中一定会有”f”，前缀中一定不含有”f”，则其没有相等的前后缀 next[5]=0</p><p>next[]数组的作用：到主串的j,子串的i 不匹配时，查next[j] = x 则子串的i回退到x这个位置(x表示比配过的相同前缀的下一个字符)</p><p>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int nextArr[100] = {0}; </p><p>/*<br>求字符串s每一个子串的最长相等前后缀的长度<br> i的每一次自增，代表的就是s的一个子串<br> 同时 i 也表示该子串的后缀结尾位置<br>  j = 0开始，j表示子串前缀结尾位置 即next[i]的值 此时j的位置不代表子串的末尾的前一个位置，而代表的是上一个子串相等前后缀的末尾位置的下一个字符<br>  前后缀相等，意味着长度，字符均相同，从结尾开始比较，只要不相同,后缀结尾不变，前缀结尾改变<br>  子串只有一个字符时，无前后缀，预先设置next[0] == 0<br>  从i=1 j=0开始（即从两个字符开始判断）<br>  判断s[j]  s[i]是否相等   不等j 依旧等于0 记录此时next[i] = j  相等j++ 指向等前后缀的末尾位置的下一个字符<br>  后期子串增加，判断s[j]  s[i]是否相等<br>  不等，意味着 之前的前缀的下一个字符现在字符后缀最后一个不限等，则跳转到上一个next[],即next[j - 1]<br>  因为之前的前缀是现在子串前缀的子集，若是之前匹配过。没有必要在匹配一次，直接判断后缀增结尾符改变后</p><p>*/</p><p>void Next(string s) {  //求next数组<br>    int n = s.size();<br>    int j = 0;<br>    for (int i = 1; i &lt; n; i++) {<br>        while (j &gt; 0 &amp;&amp; s[j] != s[i]) {<br>            j = nextArr[j - 1];<br>        }<br>        if (s[j] == s[i]) j++;<br>        nextArr[i] = j;<br>    }<br>}<br>//kmp匹配<br>bool kmp(int next[], string str, string s) {<br>    int j = 0;<br>    int n = s.size();<br>    for (int i = 0; i &lt; str.size(); i++) {<br>        while (j &gt; 0 &amp;&amp; str[i] != s[j]) {<br>            j = next[j - 1];<br>        }<br>        if (str[i] == s[j]) j++;<br>        if (j == n) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}</p><p>int main() {<br>    string str, s;<br>    cin &gt;&gt; str &gt;&gt; s;<br>    Next(s);<br>    if (kmp(nextArr, str, s)) {<br>        cout &lt;&lt; s &lt;&lt; “是” &lt;&lt; str &lt;&lt; “的子串” &lt;&lt; endl;<br>    } else {<br>        cout &lt;&lt; s &lt;&lt; “不是” &lt;&lt; str &lt;&lt; “的子串” &lt;&lt; endl;<br>    }<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组入门</title>
      <link href="/posts/777cdf84.html"/>
      <url>/posts/777cdf84.html</url>
      
        <content type="html"><![CDATA[<p>一.c++ —动态数组 std::vector (用using … std; std省略)<br>1.作用：封装了可以改变大小的数组，使其成为存储和管理动态数据集合的首选方式<br>2.用法： vector&lt;元素类型&gt;变量名;<br>3.常用操作：<br>1&gt;初始化<br>vector<int> v; // 创建一个空的 int 类型的 vector<br>vector<int> v(5, 10); // 创建一个包含 5 个元素的 vector，每个元素初始化为 10<br>vector<int> v = {1, 2, 3, 4, 5}; // 使用列表初始化<br>2&gt;添加元素(插入元素)<br>v.push_back(10); // 在 vector 的末尾添加一个元素<br>v.insert(v.begin(), 20); // 在 vector 的开头插入一个元素<br>3&gt;访问元素<br>int first = v.front(); // 获取 vector 的第一个元素<br>int last = v.back(); // 获取 vector 的最后一个元素<br>int element = v[3]; // 获取索引为 3 的元素<br>4&gt;删除元素<br>v.pop_back(); // 删除 vector 的最后一个元素<br>v.erase(v.begin() + 2); // 删除索引为 2 的元素<br>v.clear(); // 删除 vector 中的所有元素<br>5&gt;大小和容量<br>size_t size = v.size(); // 获取 vector 中的元素数量<br>size_t capacity = v.capacity(); // 获取 vector 的当前容量<br>v.resize(10); // 改变 vector 的大小为 10<br>6&gt;搜索和排序<br>auto it = find(v.begin(), v.end(), 10); // 搜索值为 10 的元素<br>if (it != v.end()) {<br>    // 元素找到<br>}<br>sort(v.begin(), v.end()); // 排序 vector 中的元素<br>7&gt;范围基于的 for 循环<br>for (int elem : v) {<br>    // 对 v 中的每个元素执行操作<br>}</p><p>注意：std::vector<string>v 和std::vector<string>v[5]的区别 前者为一位数组，后者就相当于5个长度不定的一维数组</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>11.数字反转（升级版）</title>
      <link href="/posts/777cdf84.html"/>
      <url>/posts/777cdf84.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><a href="11.数字反转（升级版）.md">text</a><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;</p><p>string transfer(string s){<br>    reverse(s.begin(), s.end()); //知识点1<br>    return s;<br>} </p><p>string zero(string s){<br>    int pos = s.find(‘0’);<br>    while(pos == 0 &amp;&amp; s.size() &gt; 1){<br>        s = s.erase(pos, 1);<br>        pos = s.find(‘0’);<br>    }<br>    return s;<br>}</p><p>int main(){<br>    string s, temp;<br>    cin &gt;&gt; s;<br>    int pos = s.find(‘.’);</p><pre><code>if (pos != string::npos) &#123; // 小数  //知识点2    temp = s;    s = s.substr(0, pos);    s = transfer(s);    s = zero(s) + temp[pos];    temp = temp.substr(pos + 1);    temp = zero(temp);    temp = transfer(temp);    //cout&lt;&lt;temp&lt;&lt;endl;    s = s + temp;&#125; else &#123;    pos = s.find(&#39;/&#39;);    if (pos != string::npos) &#123; // 分数        temp = s;        s = s.substr(0, pos);        s = transfer(s);        s = zero(s) + temp[pos];        temp = temp.substr(pos + 1);        temp = transfer(temp);        temp = zero(temp);        s = s + temp;    &#125; else &#123;        pos = s.find(&#39;%&#39;);        if (pos != string::npos) &#123; // 百分数            s = s.substr(0, s.size() - 1);  //知识点3            s = transfer(s);            s = zero(s) + &#39;%&#39;;        &#125; else &#123; // 整数            s = transfer(s);            s = zero(s);        &#125;    &#125;&#125;cout &lt;&lt; s;return 0;</code></pre><p>}</p><p>知识点：<br>1.reverse(s.begin(), s.end());<br>作用：将字符串s反转，eg:123 = 321<br>头文件：string (c++)</p><p>2.string::npos<br>作用：pos != string::npos 如果 pos 的值不等于 string::npos，则说明找到了对应的字符或子字符串。否则，表示未找到匹配。<br>在C++中，string::npos 表示 string 类型中的一个静态常量，通常用于表示未找到匹配的位置<br>注意：本身表示未找到，所以不等于才表示找到</p><p>3.s = s.substr(0, s.size() - 1);<br>作用：s.substr(起始位置，截取长度) 截取字符串  表示从0开始(包括0)，截取s.size() - 1个长度<br>头文件：string (c++)</p><p>总结：<br>1.写代码前 先思考 想出具体方法！！！以及易错点<br>例如: 去掉后面的0时，如果只判断0的位置是否在最后，则当前面有0时将无法判断<br>2.分模块实现，每写一个模块就进行测试，防止一错再错<br>3.不要过度依赖人工智能，自己判断错误</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>12.斯诺登的密码</title>
      <link href="/posts/777cdf84.html"/>
      <url>/posts/777cdf84.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><a href="pic-洛谷字符串/12.斯诺登的密码.png">alt text</a><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include<cstring></h1><p>using namespace std;<br>/<em><br>1.输入，string 先对格式不做要求<br>2.找数字 存入数组中，利用for循环遍历 存储到数组<br>3.平方 取模 去0 </em>/<br>int main(){<br>    string s[6];<br>    string snum[26] = {“one”,”two”,”three”,”four”,”five”,”six”,”seven”,”eight”,”nine”,”ten”,”eleven”,”twelve”,”thirteen”,”fourteen”,”fifteen”,”sixteen”,”seventeen”,”eighteen”,”nineteen”,”twenty”,”a”,”both”,”another”,”first”,”second”,”third”};<br>    int num[26] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,1,2,1,1,2,3};<br>    int data[6] = {0};<br>    int j = 0;</p><pre><code>for(int i = 0; i &lt; 6; i++)&#123;    cin&gt;&gt;s[i];    for(int k = 0; k &lt; 26; k++)&#123; //为什么边界是26         if(s[i] == snum[k] &amp;&amp; (num[k] * num[k]) % 100 != 0)&#123;            data[j] = (num[k] * num[k]) % 100;            j++;            break;        &#125;    &#125;&#125;if(j == 0)&#123;    cout&lt;&lt;0;    return 0;&#125;sort(data, data + j);for(int i = 0; i &lt; j; i++)&#123;    if(i != 0 &amp;&amp; data[i] &lt; 10)&#123;        cout&lt;&lt;0;    &#125;    cout&lt;&lt;data[i];&#125;return 0;</code></pre><p>}</p><p>错误原因：<br>没有彻底搞清楚题目，导致走了很多弯路，简单问题复杂化<br>知识点 + 疑惑点：<br>string snum[26] 有26个元素，数组下标仍然为26.不为25，循环时，从0开始，K &lt; 26, for(int k = 0; k &lt; 26; k++)<br>解答：元素个数比下标大一 有26个元素，下标为0 ~ 25<br>在C和C++中，定义一个数组时，需要指定数组的大小，而不是数组中元素的数量。因此，当您定义数组时，需要指定数组的大小，以便为所有元素提供足够的空间。在定义数组时，指定数组的大小应该是数组中元素的数量，而不是最后一个元素的索引。</p><p>知识补充；<br>代码：</p><h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<iostream></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include"></a>include<cstdio></h1><h1 id="include-4"><a href="#include-4" class="headerlink" title="include"></a>include<cstring></h1><h1 id="include-5"><a href="#include-5" class="headerlink" title="include"></a>include<algorithm></h1><h1 id="include-知识点：map"><a href="#include-知识点：map" class="headerlink" title="include   //知识点：map"></a>include<map>   //知识点：map</h1><p>using namespace std;<br>map<string,int>q;<br>const int mx=66;<br>int top;<br>int st[mx];<br>string s;<br>int main(){</p><pre><code> q[&quot;one&quot;]=1;q[&quot;two&quot;]=2;q[&quot;three&quot;]=3;q[&quot;four&quot;]=4;q[&quot;five&quot;]=5;q[&quot;six&quot;]=6;q[&quot;seven&quot;]=7;q[&quot;eight&quot;]=8;q[&quot;nine&quot;]=9;q[&quot;ten&quot;]=10； q[&quot;eleven&quot;]=11;q[&quot;twelve&quot;]=12;q[&quot;thirteen&quot;]=13;q[&quot;fourteen&quot;]=14;q[&quot;fifteen&quot;]=15;q[&quot;sixteen&quot;]=16;q[&quot;seventeen&quot;]=17;q[&quot;eighteen&quot;]=18;q[&quot;nineteen&quot;]=19;q[&quot;twenty&quot;]=20; q[&quot;a&quot;]=1;q[&quot;both&quot;]=2;q[&quot;another&quot;]=1;q[&quot;first&quot;]=1;q[&quot;second&quot;]=2;q[&quot;third&quot;]=3; //打表 for(int i=1;i&lt;=6;i++)&#123;     cin&gt;&gt;s;     if(q[s])&#123;//如果可以构成数字         int k=q[s]*q[s]%100;         if(k==0)continue;//要是为0就没有必要存了         st[++top]=k;     &#125; &#125; sort(st+1,st+top+1);//从小到大排 cout&lt;&lt;st[1]; for(int i=2;i&lt;=top;i++)&#123;     if(st[i]&lt;10)cout&lt;&lt;0;//不这样只能拿10分     cout&lt;&lt;st[i]; &#125; return 0;</code></pre><p>}</p><p>知识点：map</p><p><map> 是标准模板库（STL）的一部分，它提供了一种关联容器，用于存储键值对（key-value pairs）。<br>map 容器中的元素是按照键的顺序自动排序的，这使得它非常适合需要快速查找和有序数据的场景</p><p>1.定义：map<key_type, value_type> myMap; 相当于：一个二元组对，第一列和第二列 利用map构成了一种一一对应的映射关系<br>eg：map<string,int>q;<br>2.使用/初始化：myMap[key] = value; 变量名[第一个元素值] = 第二个元素值;<br>eg: q[“one”]=1; q[“two”]=2; q[“three”]=3;</p><p>3.定义和特性<br>键值对：map 存储的是键值对，其中每个键都是唯一的。<br>排序：map 中的元素按照键的顺序自动排序，通常是升序。<br>唯一性：每个键在 map 中只能出现一次。<br>双向迭代器：map 提供了双向迭代器，可以向前和向后遍历元素。</p><ol><li>访问元素：value = myMap[key];<br>eg: int k=q[s]*q[s]%100;</li></ol><p>5.遍历元素：<br>for (map<key_type, value_type>::iterator it = myMap.begin(); it != myMap.end(); ++it) {<br>    cout &lt;&lt; it-&gt;first &lt;&lt; “ =&gt; “ &lt;&lt; it-&gt;second &lt;&lt; endl;<br>}</p><p>实例<br>下面是一个使用 map 的简单实例，我们将创建一个 map 来存储员工的姓名和他们的年龄，并遍历这个 map 来打印每个员工的姓名和年龄。</p><p>实例</p><h1 id="include-include"><a href="#include-include" class="headerlink" title="include #include "></a>include <iostream>#include <map></h1><h1 id="include-6"><a href="#include-6" class="headerlink" title="include "></a>include <string></h1><p>int main() {<br>    // 创建一个 map 容器，存储员工的姓名和年龄<br>    std::map<std::string, int> employees;</p><pre><code>// 插入员工信息employees[&quot;Alice&quot;] = 30;employees[&quot;Bob&quot;] = 25;employees[&quot;Charlie&quot;] = 35;// 遍历 map 并打印员工信息for (std::map&lt;std::string, int&gt;::iterator it = employees.begin(); it != employees.end(); ++it) &#123;    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot; is &quot; &lt;&lt; it-&gt;second &lt;&lt; &quot; years old.&quot; &lt;&lt; std::endl;&#125;return 0;</code></pre><p>}<br>输出结果:</p><p>Alice is 30 years old.<br>Bob is 25 years old.<br>Charlie is 35 years old.</p><p>进阶用法</p><p>6.检查键是否存在:<br>if (myMap.find(key) != myMap.end()) {<br>    // 键存在<br>}</p><p>7.删除元素:<br>myMap.erase(key);</p><p>8.清空:<br>myMap.clear();</p><p>9.获取 map 的大小:<br>size_t size = myMap.size();</p><p>10.使用自定义比较函数:</p><p>实例</p><h1 id="include-7"><a href="#include-7" class="headerlink" title="include "></a>include <map></h1><h1 id="include-8"><a href="#include-8" class="headerlink" title="include "></a>include <string></h1><h1 id="include-9"><a href="#include-9" class="headerlink" title="include "></a>include <functional></h1><p>bool myCompare(const std::string&amp; a, const std::string&amp; b) {<br>    return a &lt; b;<br>}</p><p>int main() {<br>    std::map<std::string, int, std::function<bool(const std::string&, const std::string&)>&gt; myMap(myCompare);</p><pre><code>// 其他操作...return 0;</code></pre><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5. kotori和素因子（A组，B组）</title>
      <link href="/posts/4c507725.html"/>
      <url>/posts/4c507725.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/5. kotori和素因子（A组，B组）.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <bits/stdc++.h></h1><p>using namespace std;<br>/<em><br>思路总结：<br>1.保存1000以内的质数—埃拉托斯特尼筛法<br>2.求出所有整数的所有素因子—动态二维数组<br>3.dfs求出最小素因子之和</em>/<br>int ans = 9999999;<br>int n;<br>int vis[10001];</p><p>vector<int>v[100];<br>const int MAX = 1001;<br>bool prime[MAX];<br>// 埃拉托斯特尼筛法<br>void init(){<br>    fill(prime,prime + MAX,true); //初始化全为质数<br>    for(int i = 2 ; i <em> i &lt; MAX; ++i){<br>        if(prime[i]){<br>            for(int j = i </em> i; j &lt; MAX; j+=i){<br>                prime[j] = false;<br>            }<br>        }<br>    }<br>}<br>void dfs(int d,int sum){//重点<br>    if(d == n){//先写退出条件—深度达到最大值<br>        ans = min(ans,sum);<br>        return;<br>    }<br>    for(int i = 0; i &lt; v[d].size(); i++){//从最底层开始，一次选一个值<br>        if(!vis[v[d][i]]){<br>            vis[v[d][i]] = 1;//标记该值，表已经被用过<br>            dfs(d + 1, sum + v[d][i]); //选完一个换下一个<br>            vis[v[d][i]] = 0; //上一个选完后回头，换一个路，将之前标记过的值还原<br>        }<br>    }<br>}<br>int main(){<br>    init();<br>    scanf(“%d”,&amp;n);<br>    for(int i = 0; i &lt; n; i++){<br>        int temp;<br>        scanf(“%d”,&amp;temp);<br>        for(int j = 2; j &lt;= temp; j++){<br>            if(prime[j]&amp;&amp;temp % j == 0){<br>                v[i].push_back(j);<br>            }<br>        }<br>    }<br>    dfs(0,0);<br>    if(ans == 9999999) printf(“-1\n”);<br>    else printf(“%d\n”,ans);<br>    return 0;<br>} </p><p>c语言版</p><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <stdio.h></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <string.h></h1><p>int ans = 9999999;<br>int n;<br>int vis[10001];</p><p>int v[100][100];<br>const int MAX = 1001;<br>int prime[MAX];</p><p>void init() {<br>    memset(prime, 1, sizeof(prime)); // 初始化全为质数<br>    for (int i = 2; i <em> i &lt; MAX; ++i) {<br>        if (prime[i]) {<br>            for (int j = i </em> i; j &lt; MAX; j += i) {<br>                prime[j] = 0;<br>            }<br>        }<br>    }<br>}</p><p>void dfs(int d, int sum) {<br>    if (d == n) {<br>        ans = ans &lt; sum ? ans : sum;<br>        return;<br>    }<br>    for (int i = 0; i &lt; 100; i++) {<br>        if (v[d][i] != 0 &amp;&amp; !vis[v[d][i]]) {<br>            vis[v[d][i]] = 1;<br>            dfs(d + 1, sum + v[d][i]);<br>            vis[v[d][i]] = 0;<br>        }<br>    }<br>}</p><p>int main() {<br>    init();<br>    scanf(“%d”, &amp;n);<br>    for (int i = 0; i &lt; n; i++) {<br>        int temp;<br>        scanf(“%d”, &amp;temp);<br>        int k = 0;<br>        for (int j = 2; j &lt;= temp; j++) {<br>            if (prime[j] &amp;&amp; temp % j == 0) {<br>                v[i][k] = j;<br>                k++;<br>            }<br>        }<br>    }<br>    dfs(0, 0);<br>    if (ans == 9999999) printf(“-1\n”);<br>    else printf(“%d\n”, ans);<br>    return 0;<br>}<br>错误点：<br>c语言没有vector 但不一定非要知道数组的大小，设置一个足够大的数组范围，判断其元素值不为0即可停止 (因为数组有效元素不为0)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>10.单词覆盖还原</title>
      <link href="/posts/0.html"/>
      <url>/posts/0.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br>heo/source/_posts/洛谷-题单-字符串-代码/10.单词覆盖还原.md<br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    int numboy = 0,numgirl = 0;<br>    string s;<br>    cin&gt;&gt;s;</p><pre><code>for(int i = 0; i&lt;s.size();i++)&#123;    //cout&lt;&lt;&quot;i--&gt;&quot;&lt;&lt;i&lt;&lt;&quot; &quot;;    if(s[i] == &#39;b&#39;)&#123;        if(s[i + 1] == &#39;o&#39;)&#123;            if(s[i + 2] == &#39;y&#39;)&#123;                numboy++;                i = i+2;            //    cout&lt;&lt;endl&lt;&lt;&quot;boy&quot;&lt;&lt;endl;            &#125;            else&#123;                numboy++;                i = i+1;            //    cout&lt;&lt;endl&lt;&lt;&quot;bo&quot;&lt;&lt;endl;            &#125;        &#125;        else&#123;            //i++;            numboy++;        //    cout&lt;&lt;endl&lt;&lt;&quot;b&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;o&#39;)&#123;        if(s[i + 1] == &#39;y&#39;)&#123;            numboy++;            i = i+1;                //cout&lt;&lt;endl&lt;&lt;&quot;oy&quot;&lt;&lt;endl;        &#125;        else&#123;            //i++;            numboy++;            //cout&lt;&lt;endl&lt;&lt;&quot;o&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;y&#39;)&#123;        //cout&lt;&lt;endl&lt;&lt;i;        //i++;        numboy++;        //cout&lt;&lt;endl&lt;&lt;&quot;y&quot;&lt;&lt;endl;    &#125;    else if(s[i] == &#39;g&#39;)&#123;        if(s[i + 1] == &#39;i&#39;)&#123;            if(s[i + 2] == &#39;r&#39;)&#123;                if(s[i + 3] == &#39;l&#39;)&#123;                    numgirl++;                    i = i+3;                    //cout&lt;&lt;endl&lt;&lt;&quot;girl&quot;&lt;&lt;endl;                    //cout&lt;&lt;endl&lt;&lt;i;                &#125;                else&#123;                    numgirl++;                    i = i+2;                //    cout&lt;&lt;endl&lt;&lt;&quot;gir&quot;&lt;&lt;endl;                &#125;            &#125;            else&#123;                numgirl++;                i = i+1;                //cout&lt;&lt;endl&lt;&lt;&quot;gi&quot;&lt;&lt;endl;            &#125;        &#125;        else&#123;            numgirl++;            //cout&lt;&lt;endl&lt;&lt;&quot;g&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;i&#39;)&#123;        if(s[i + 1] == &#39;r&#39;)&#123;            if(s[i + 2] == &#39;l&#39;)&#123;                numgirl++;                i = i+2;                    //cout&lt;&lt;endl&lt;&lt;&quot;irl&quot;&lt;&lt;endl;            &#125;            else&#123;                numgirl++;                i = i+1;                    //cout&lt;&lt;&quot;ir&quot;&lt;&lt;endl;            &#125;        &#125;else&#123;            numgirl++;            //    cout&lt;&lt;endl&lt;&lt;&quot;i&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;r&#39;)&#123;        if(s[i + 1] == &#39;l&#39;)&#123;            numgirl++;            i = i+1;                //cout&lt;&lt;endl&lt;&lt;&quot;rl&quot;&lt;&lt;endl;        &#125;        else&#123;            numgirl++;            //cout&lt;&lt;endl&lt;&lt;&quot;r&quot;&lt;&lt;endl;        &#125;    &#125;    else if(s[i] == &#39;l&#39;)&#123;        //i++;        numgirl++;        //cout&lt;&lt;endl&lt;&lt;&quot;l&quot;&lt;&lt;endl;    &#125;&#125;cout&lt;&lt;numboy&lt;&lt;endl&lt;&lt;numgirl;return 0;</code></pre><p>}<br>错误：if里面不能用break;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>9.小果的键盘</title>
      <link href="/posts/2532b67f.html"/>
      <url>/posts/2532b67f.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="../练习题/牛客/pic-牛客/9.小果的键盘.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    int n;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    int num = 0;</p><pre><code>for(int i = 0;i &lt; s.size() - 1;i++)&#123;    if(s[i] == &#39;V&#39; &amp;&amp; s[i + 1] == &#39;K&#39;)&#123;        num++;        s[i] = s[i + 1] = 0;    &#125;&#125;int pos = s.find(&quot;VV&quot;);if(pos &gt;= 0)&#123;    num++;&#125;else&#123;    pos = s.find(&quot;KK&quot;);    if(pos &gt;= 0) num++;&#125;cout&lt;&lt;num;return 0;</code></pre><p>}<br>错误原因：<br>1.s.find(“VV”)<br>函数引用字符串用””,引用字符时用’’<br>2.s.size()<br>忘记写括号导致出错<br>3.利用最朴素的方法做，不出错超时在考虑其他方法，不要总想着用现成函数，容易出错<br>4.出错时学会改变条件<br>eg:最初想法是 删去VK后的字符串，若长度大于1，且V第一次出现的位置不在最后，说明不是‘KV’的情况，num+1 错误<br>    则改变“互补”条件：只要有“VV”,”KK”时num就+1</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8.手机</title>
      <link href="/posts/b114fdb0.html"/>
      <url>/posts/b114fdb0.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-洛谷字符串/8.手机.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    string str;<br>    int num = 0;<br>    getline(cin,str);<br>    for(int i = 0; i &lt; str.size(); i++){<br>        if(str[i] == ‘a’ ||str[i] == ‘d’ ||str[i] == ‘g’ ||str[i] == ‘j’ ||str[i] == ‘m’ ||str[i] == ‘p’||str[i] == ‘t’ ||str[i] == ‘w’){<br>            num++;<br>        }<br>        else if(str[i] == ‘b’ ||str[i] == ‘e’ ||str[i] == ‘h’ ||str[i] == ‘k’ ||str[i] == ‘n’ ||str[i] == ‘q’ ||str[i] == ‘u’ ||str[i] == ‘x’){<br>            num = num + 2;<br>        }<br>        else if(str[i] == ‘c’ ||str[i] == ‘f’ ||str[i] == ‘i’ ||str[i] == ‘l’ ||str[i] == ‘o’ ||str[i] == ‘r’ ||str[i] == ‘v’ ||str[i] == ‘y’){<br>            num = num + 3;<br>        }<br>        else if(str[i] == ‘s’ || str[i] == ‘z’){<br>            num = num + 4;<br>        }<br>        else num++;<br>    }<br>    cout&lt;&lt;num;<br>    return 0;<br>}<br>更好的思路：</p><h1 id="include”iostream”"><a href="#include”iostream”" class="headerlink" title="include”iostream”"></a>include”iostream”</h1><h1 id="include”cstdio”"><a href="#include”cstdio”" class="headerlink" title="include”cstdio”"></a>include”cstdio”</h1><h1 id="include”cstring”-为用strchr查找函数"><a href="#include”cstring”-为用strchr查找函数" class="headerlink" title="include”cstring”//为用strchr查找函数"></a>include”cstring”//为用strchr查找函数</h1><p>using namespace std;<br>char s1[]={“ adgjmptw”},s2[]={“behknqux”},s3[]={“cfilorvy”},s4[]={“sz”};//可以望文生义，分别开按1~4次键盘的常量数组<br>int main()<br>{<br> char c;<br> int s=0;<br> while((c=getchar())!=EOF) //！=EOF表示还没输入结束<br>  {<br>  //在s1~s4中依次找，找到就加上1~4<br>   if(strchr(s1,c)) s++;<br>   else if(strchr(s2,c)) s+=2;<br>   else if(strchr(s3,c)) s+=3;<br>   else if(strchr(s4,c)) s+=4; //注意这里不能写成else，因为还会有\n等字符<br>  }<br> cout&lt;&lt;s&lt;&lt;endl;<br> r</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4.（A组，B组）</title>
      <link href="/posts/c48970d5.html"/>
      <url>/posts/c48970d5.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/4.（A组，B组）.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    long long n,result = 0;<br>    string s;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    int num[26] = {0},dp[26] = {0};<br>    for(int i = 0; i &lt; n;i++){<br>        result = result + dp[s[i] - ‘a’];<br>        dp[s[i] - ‘a’] += i - num[s[i] - ‘a’];<br>        num[s[i] - ‘a’]++;<br>    }<br>    cout&lt;&lt;result;<br>    return 0;<br>}<br>方法思想：动态规划<br>eg:abcbcc<br>判断“abb”式的大体思想是：第一个字符和第二个字符不同，第二个字符和第三个字符相同 == 每遍历一个字符“b”，判断在此之前有多少个“ab”<br>重难点:如何判断在此之前有多少个“ab”：用当前遍历的元素个数 - 该元素此前出现的次数 剩下的就是与该元素不同的元素，只要不同就能构成一个“ab”，能构成一个“ab”，该元素就能构成多少个“abb”<br>需要的变量：result存储结果，dp[26]存储构成的“ab”数量，num[26]存储不同字母出现的次数</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3.红色和紫色</title>
      <link href="/posts/c6f25b8.html"/>
      <url>/posts/c6f25b8.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/3.红色和紫色.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><p>using namespace std;</p><p>int main(){<br>    int n = 0;<br>    int m = 0;<br>    while(n &lt; 1){<br>        cin&gt;&gt;n;<br>    }<br>     while(m &lt; 1){<br>        cin&gt;&gt;m;<br>    }<br>    if(n % 2 == 1 &amp;&amp; m % 2 == 1){<br>        cout&lt;&lt;”akai”;<br>    }<br>    else{<br>        cout&lt;&lt;”yukari”;<br>    }<br>    return 0;<br>}<br>疑问：<br>为什么(n % 2 == 1 &amp;&amp; m % 2 == 1)这个是对的，(n * m % 2 == 1 )这个是错的</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6.文字处理软件</title>
      <link href="/posts/e8344066.html"/>
      <url>/posts/e8344066.html</url>
      
        <content type="html"><![CDATA[<p>题目：<img src="pic-洛谷字符串/6.文字处理软件.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<cstring></h1><p>using namespace std;</p><p>int amount,num;<br>string first,last;</p><p>void insertlast(){<br>    string str;<br>    cin&gt;&gt;str;<br>    last = last.append(str);//知识点1<br>    cout&lt;<last<<endl;     amount--;}void acquire(){    int a,b;    cin>&gt;a&gt;&gt;b;<br>    if(a &gt; last.size() - 1){<br>        a = last.size() - 1;<br>        b = 0;<br>    }<br>    else if(a + b &gt; last.size()){<br>        b = last.size() - a ;<br>    }<br>    string str(last,a,b); //知识点3<br>    last = str;<br>    cout&lt;<last<<endl;     amount--;}void insertmid(){    int a;    string str;    cin>&gt;a&gt;&gt;str;<br>    if(a &gt; last.size() - 1 ){<br>        a = last.size() - 1;<br>    }<br>    last.insert(a,str); //知识点4<br>    cout&lt;<last<<endl;    amount--;}void search(){    string str;    cin>&gt;str;<br>    int a = last.find(str);//知识点5<br>    cout&lt;<a<<endl;    amount--;}int main(){    cin>&gt;amount&gt;&gt;last;<br>    while(amount != 0){<br>        //cout&lt;&lt;”返回,输入num”&lt;<endl;        cin>&gt;num;<br>        switch(num){<br>            case 1: insertlast();break;<br>            case 2: acquire();break;<br>            case 3: insertmid();break;<br>            case 4: search();break;<br>        }<br>    }<br>    return 0;<br>}<br>知识点：<br>1.last = last.append(str) append()<br>作用：将括号里的字符串拼接到目标字符串的末尾<br>用法：争对string类型（c++）<br>头文件：#include <string></p><p>2.扩展：strcat(dest,src)<br>作用：strcat 函数将 src 串拼接到 dest 串之后<br>用法：争对char[]类型（c++/c）<br>头文件：C语言：#include<string.h></p><p>3.string str(last,a,b);<br>作用：建立字符串，等于，从last的第a（第一个从0开始数）个字符开始的b（包括a）个元素的字符串<br>用法：争对string类型（c++）<br>头文件：#include <string></p><p>4.last.insert(a,str);<br>作用：在第a个位置之前插入str字符串；<br>用法：争对string类型（c++）<br>头文件：#include <string></p><p>5.int a = last.find(str);<br>作用：在目标字符串a中找字符串str的最先的位置，如果找不到输出-1<br>用法：争对string类型（c++）<br>头文件：#include <string></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5.标题统计</title>
      <link href="/posts/f85195b5.html"/>
      <url>/posts/f85195b5.html</url>
      
        <content type="html"><![CDATA[<p>题目：<img src="pic-洛谷字符串/5.标题统计.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include"></a>include<cstring></h1><p>using namespace std;</p><p>int main(){<br>    string s;<br>    getline(cin,s); //知识点1<br>    int length = s.size();<br>    for(int i = 0; i &lt; s.size(); i++){<br>        if(s[i] - 32 == 0 || s[i] == ‘\n’){<br>            length—;<br>        }<br>    }<br>    cout&lt;&lt;length;<br>    return 0;<br>}<br>官方代码：</p><h1 id="include-3"><a href="#include-3" class="headerlink" title="include"></a>include<bits/stdc++.h></h1><p>using namespace std;<br>int main(){<br>    int ans=0;<br>    char c;<br>    if(cin&gt;&gt;c)ans++; //cin自动去除空格换行<br>    if(cin&gt;&gt;c)ans++; //cin在读不到数据时返回0<br>    if(cin&gt;&gt;c)ans++; //因为题目规定标题不超过5个字符，所以可这样做<br>    if(cin&gt;&gt;c)ans++;<br>    if(cin&gt;&gt;c)ans++;<br>    cout&lt;&lt;ans;<br>}<br>知识点：<br>1.getline(cin,s)和 get(s)<br>可输入带空格，换行等符号的字符串</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7.统计单词数</title>
      <link href="/posts/f706c1aa.html"/>
      <url>/posts/f706c1aa.html</url>
      
        <content type="html"><![CDATA[<p>题目：<img src="pic-洛谷字符串/7.统计单词数.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <cmath></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <algorithm></h1><p>using namespace std;</p><p>int main(){<br>    string intend,passage;<br>    int num = 0,first = 0;<br>    getline(cin,intend);<br>    getline(cin,passage);//输入<br>    for(int i = 0; i &lt; intend.size();i++){<br>        intend[i] = tolower(intend[i]);<br>    }<br>    for(int i = 0; i &lt; passage.size();i++){<br>        passage[i] = tolower(passage[i]);<br>    }//统一格式<br>    intend = intend.append(“ “);      //a=’ ‘+a+’ ‘;<br>                                        b=’ ‘+b+’ ‘;//简单写法<br>    intend = intend.insert(0,” “);<br>    passage = passage.append(“ “);<br>    passage = passage.insert(0,” “);<br>    first = passage.find(intend);<br>    int z = first;<br>    if(first &lt; 0){<br>        cout&lt;<first;        return 0 ;    }    while(z >= 0){<br>        string str(passage,z + intend.size() - 1,passage.size() - 1);<br>        z = str.find(intend);<br>        passage = str;<br>        num++;<br>    }<br>    cout&lt;&lt;num&lt;&lt;” “&lt;&lt;first;<br>    return 0;<br>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷-题单-字符串入门</title>
      <link href="/posts/c7172a2b.html"/>
      <url>/posts/c7172a2b.html</url>
      
        <content type="html"><![CDATA[<p>C语言字符串函数：头文件：#include <string.h><br>1.stpcpy<br>作用：复制字符串<br>用法：stpcpy(目标串变量,被复制字符串变量);<br>2.strcat<br>作用：拼接字符串<br>用法：strcat(目标串变量,被拼接字符串变量)<br>3.strchr<br>作用：<br>用法：<br>4.<br>作用：<br>用法：<br>5.<br>作用：<br>用法：</p><p>C++知识点<br>一.string类<br>作用：约等于char,是 C++用来代替 char 数组的数据结构,且是动态变化的，不用对大小进行约束</p><p>结构：是一个类，为一个顺序表，类的内部封装了char*</p><p>在使用string类时，必须包含 #include 头文件以及  using namespace std</p><p>用法：<br>一. string的构造函数的形式：<br>string str：生成空字符串</p><p>string s(str)：生成字符串为str的复制品</p><p>string s(str, strbegin,strlen)：将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</p><p>string s(cstr, char_len)：以C_string类型cstr的前char_len个字符串作为字符串s的初值</p><p>string s(num ,c)：生成num个c字符的字符串</p><p>string s(str, stridx)：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</p><p>eg:</p><pre><code>string str1;               //生成空字符串string str2(&quot;123456789&quot;);  //生成&quot;1234456789&quot;的复制品string str3(&quot;12345&quot;, 0, 3);//结果为&quot;123&quot;string str4(&quot;012345&quot;, 5);  //结果为&quot;01234&quot;string str5(5, &#39;1&#39;);       //结果为&quot;11111&quot;string str6(str2, 2);      //结果为&quot;3456789&quot;二. string的大小和容量：</code></pre><ol><li><p>size()和length()：返回string对象的字符个数，他们执行效果相同。</p></li><li><p>max_size()：返回string对象最多包含的字符数，超出会抛出length_error异常</p></li><li><p>capacity()：重新分配内存之前，string对象能包含的最大字符数<br>void test2()<br>{<br> string s(“1234567”);<br> cout &lt;&lt; “size=” &lt;&lt; s.size() &lt;&lt; endl;<br> cout &lt;&lt; “length=” &lt;&lt; s.length() &lt;&lt; endl;<br> cout &lt;&lt; “max_size=” &lt;&lt; s.max_size() &lt;&lt; endl;<br> cout &lt;&lt; “capacity=” &lt;&lt; s.capacity() &lt;&lt; endl;</p></li></ol><p>}<br>三. string的字符串比较：</p><ol><li><p>C ++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较(如 str&lt;”hello”)。<br>在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，<br>比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小(前面减后面)<br>同时，string (“aaaa”) &lt;string(aaaaa)。    </p></li><li><p>另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。<br>他返回一个整数来表示比较结果，返回值意义如下：0：相等 1：大于 -1：小于 (A的ASCII码是65，a的ASCII码是97)<br>void test3()<br>{<br> // (A的ASCII码是65，a的ASCII码是97)<br> // 前面减去后面的ASCII码，&gt;0返回1，&lt;0返回-1，相同返回0<br> string A(“aBcd”);<br> string B(“Abcd”);<br> string C(“123456”);<br> string D(“123dfg”);</p><p> // “aBcd” 和 “Abcd”比较——— a &gt; A<br> cout &lt;&lt; “A.compare(B)：” &lt;&lt; A.compare(B)&lt;&lt; endl;                          // 结果：1</p><p> // “cd” 和 “Abcd”比较———- c &gt; A<br> cout &lt;&lt; “A.compare(2, 3, B):” &lt;&lt;A.compare(2, 3, B)&lt;&lt; endl;                // 结果：1</p><p> // “cd” 和 “cd”比较<br> cout &lt;&lt; “A.compare(2, 3, B, 2, 3):” &lt;&lt; A.compare(2, 3, B, 2, 3) &lt;&lt; endl;  // 结果：0</p></li></ol><pre><code>// 由结果看出来：0表示下标，3表示长度// &quot;123&quot; 和 &quot;123&quot;比较 cout &lt;&lt; &quot;C.compare(0, 3, D, 0, 3)&quot; &lt;&lt;C.compare(0, 3, D, 0, 3) &lt;&lt; endl;    // 结果：0</code></pre><p>}<br>四. string的插入：push_back() 和 insert()<br>void  test4()<br>{<br>    string s1;</p><pre><code>// 尾插一个字符s1.push_back(&#39;a&#39;);s1.push_back(&#39;b&#39;);s1.push_back(&#39;c&#39;);cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:abc// insert(pos,char):在制定的位置pos前插入字符chars1.insert(s1.begin(),&#39;1&#39;);cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:1abc</code></pre><p>}<br>五、string拼接字符串：append()<br>void test5()<br>{<br>    // 方法一：append()<br>    string s1(“abc”);<br>    s1.append(“def”);<br>    cout&lt;&lt;”s1:”&lt;&lt;s1&lt;&lt;endl; // s1:abcdef</p><pre><code>// 方法二：+ 操作符string s2 = &quot;abc&quot;;/*s2 += &quot;def&quot;;*/string s3 = &quot;def&quot;;s2 += s3.c_str();cout&lt;&lt;&quot;s2:&quot;&lt;&lt;s2&lt;&lt;endl; // s2:abcdef</code></pre><p>}<br>六、 string的遍历：借助迭代器 或者 下标法<br>void test6()<br>{<br>    string s1(“abcdef”); // 调用一次构造函数</p><pre><code>// 方法一： 下标法for( int i = 0; i &lt; s1.size() ; i++ )&#123;    cout&lt;&lt;s1[i];&#125;cout&lt;&lt;endl;// 方法二：正向迭代器string::iterator iter = s1.begin();for( ; iter &lt; s1.end() ; iter++)&#123;    cout&lt;&lt;*iter;&#125;cout&lt;&lt;endl;// 方法三：反向迭代器string::reverse_iterator riter = s1.rbegin();for( ; riter &lt; s1.rend() ; riter++)&#123;    cout&lt;&lt;*riter;&#125;cout&lt;&lt;endl;</code></pre><p>}<br>七、 string的删除：erase()</p><ol><li><p>iterator erase(iterator p);//删除字符串中p所指的字符</p></li><li><p>iterator erase(iterator first, iterator last);//删除字符串中迭代器</p></li></ol><p>区间[first,last)上所有字符</p><ol><li>string&amp; erase(size_t pos = 0, size_t len = npos);//删除字符串中从索引</li></ol><p>位置pos开始的len个字符</p><ol><li>void clear();//删除字符串中所有字符<br>void test6()<br>{<br> string s1 = “123456789”;</li></ol><pre><code>// s1.erase(s1.begin()+1);              // 结果：13456789// s1.erase(s1.begin()+1,s1.end()-2);   // 结果：189s1.erase(1,6);                       // 结果：189string::iterator iter = s1.begin();while( iter != s1.end() )&#123;    cout&lt;&lt;*iter;    *iter++;&#125;cout&lt;&lt;endl;</code></pre><p>}<br>八、 string的字符替换：</p><ol><li>string&amp; replace(size_t pos, size_t n, const char *s);//将当前字符串</li></ol><p>从pos索引开始的n个字符，替换成字符串s</p><ol><li><p>string&amp; replace(size_t pos, size_t n, size_t n1, char c); //将当前字符串从pos索引开始的n个字符，替换成n1个字符c</p></li><li><p>string&amp; replace(iterator i1, iterator i2, const char* s);//将当前字符串[i1,i2)区间中的字符串替换为字符串s<br>void test7()<br>{<br> string s1(“hello,world!”);</p><p> cout&lt;&lt;s1.size()&lt;&lt;endl;                     // 结果：12<br> s1.replace(s1.size()-1,1,1,’.’);           // 结果：hello,world.</p><p> // 这里的6表示下标  5表示长度<br> s1.replace(6,5,”girl”);                    // 结果：hello,girl.<br> // s1.begin(),s1.begin()+5 是左闭右开区间<br> s1.replace(s1.begin(),s1.begin()+5,”boy”); // 结果：boy,girl.<br> cout&lt;&lt;s1&lt;&lt;endl;<br>}<br>九、 string的大小写转换：tolower() 大转小 和toupper()函数 或者 STL中的transform算法<br>法一：使用C语言之前的方法，使用函数，进行转换</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p></li></ol><p>int main()<br>{<br>    string s = “ABCDEFG”;</p><pre><code>for( int i = 0; i &lt; s.size(); i++ )&#123;    s[i] = tolower(s[i]);&#125;cout&lt;&lt;s&lt;&lt;endl;return 0;</code></pre><p>}<br>法二：通过STL的transform算法配合的toupper和tolower来实现该功能</p><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <algorithm></h1><h1 id="include-4"><a href="#include-4" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main()<br>{<br>    string s = “ABCDEFG”;<br>    string result;</p><pre><code>transform(s.begin(),s.end(),s.begin(),::tolower);cout&lt;&lt;s&lt;&lt;endl;return 0;</code></pre><p>}<br>十、 string的查找：find</p><ol><li><p>size_t find (constchar* s, size_t pos = 0) const;</p><p>//在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，</p><p> -1表示查找不到子串</p></li><li><p>size_t find (charc, size_t pos = 0) const;</p><p>//在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，</p><p> -1表示查找不到字符</p></li><li><p>size_t rfind (constchar* s, size_t pos = npos) const;</p><p>//在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，</p><p> -1表示查找不到子串</p></li><li><p>size_t rfind (charc, size_t pos = npos) const;</p><p>//在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_tfind_first_of (const char* s, size_t pos = 0) const;</p><p>//在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_tfind_first_not_of (const char* s, size_t pos = 0) const;</p><p>//在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_t find_last_of(const char* s, size_t pos = npos) const;</p><p>//在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，-1表示查找不到字符</p></li><li><p>size_tfind_last_not_of (const char* s, size_t pos = npos) const;</p><p>//在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索引，-1表示查找不到子串<br>void test8()<br>{<br> string s(“dog bird chicken bird cat”);</p><p> //字符串查找——-找到后返回首字母在字符串中的下标</p><p> // 1. 查找一个字符串<br> cout &lt;&lt; s.find(“chicken”) &lt;&lt; endl;        // 结果是：9</p><p> // 2. 从下标为6开始找字符’i’，返回找到的第一个i的下标<br> cout &lt;&lt; s.find(‘i’,6) &lt;&lt; endl;            // 结果是：11</p><p> // 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标<br> cout &lt;&lt; s.rfind(“chicken”) &lt;&lt; endl;       // 结果是：9</p><p> // 4. 从字符串的末尾开始查找字符<br> cout &lt;&lt; s.rfind(‘i’) &lt;&lt; endl;             // 结果是：18———-因为是从末尾开始查找，所以返回第一次找到的字符</p><p> // 5. 在该字符串中查找第一个属于字符串s的字符<br> cout &lt;&lt; s.find_first_of(“13br98”) &lt;&lt; endl;  // 结果是：4—-b</p><p> // 6. 在该字符串中查找第一个不属于字符串s的字符———先匹配dog，然后bird匹配不到，所以打印4<br> cout &lt;&lt; s.find_first_not_of(“hello dog 2006”) &lt;&lt; endl; // 结果是：4<br> cout &lt;&lt; s.find_first_not_of(“dog bird 2006”) &lt;&lt; endl;  // 结果是：9</p><p> // 7. 在该字符串最后中查找第一个属于字符串s的字符<br> cout &lt;&lt; s.find_last_of(“13r98”) &lt;&lt; endl;               // 结果是：19</p><p> // 8. 在该字符串最后中查找第一个不属于字符串s的字符———先匹配t—a—-c，然后空格匹配不到，所以打印21<br> cout &lt;&lt; s.find_last_not_of(“teac”) &lt;&lt; endl;            // 结果是：21</p></li></ol><p>}<br>十一、 string的排序：sort(s.begin(),s.end())</p><h1 id="include-5"><a href="#include-5" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-6"><a href="#include-6" class="headerlink" title="include "></a>include <algorithm></h1><h1 id="include-7"><a href="#include-7" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>void test9()<br>{<br>    string s = “cdefba”;<br>    sort(s.begin(),s.end());<br>    cout&lt;&lt;”s:”&lt;&lt;s&lt;&lt;endl;     // 结果：abcdef<br>}<br>十二、 string的分割/截取字符串：strtok() &amp; substr()<br>void test10()b<br>{<br>    char str[] = “I,am,a,student; hello world!”;</p><pre><code>const char *split = &quot;,; !&quot;;char *p2 = strtok(str,split);while( p2 != NULL )&#123;    cout&lt;&lt;p2&lt;&lt;endl;    p2 = strtok(NULL,split);&#125;</code></pre><p>}<br>void test11()<br>{<br>    string s1(“0123456789”);<br>    string s2 = s1.substr(2,5); // 结果：23456——-参数5表示：截取的字符串的长度<br>    cout&lt;&lt;s2&lt;&lt;endl;<br>}</p><p>二.相应头文件<br>1.using namespace std; :<br>引入命名空间 std 中的所有符号，这样在代码中就可以直接使用标准库中的函数、类、对象等，而不需要在每个标准库的成员前面加上 std:: 前缀<br>2.#include<cstring><br>提供了一些用于处理字符串的函数，比如字符串复制、连接、比较等。这个头文件通常用于 C 风格的字符串操作。<br>3.#include<iostream><br>它提供了 C++ 标准输入输出流的支持。包含这个头文件可以让你在程序中使用标准的输入输出流，比如 std::cout 和 std::cin<br>4.#include<cstdio><br>提供了一些函数来进行输入和输出操作，比如 printf 和 scanf。这个头文件通常用于 C 风格的输入输出操作。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>洛谷-题单-字符串入门-代码</title>
      <link href="/posts/4cd84e39.html"/>
      <url>/posts/4cd84e39.html</url>
      
        <content type="html"><![CDATA[<p>题目：自动修正<br><img src="pic/自动修正.png" alt="alt text"></p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    string s;<br>    cin&gt;&gt;s;<br>    for(int i = 0; i &lt; s.length();i++){<br>        s[i] = toupper(s[i]);<br>    }<br>    cout&lt;<s;    return 0;}错误原因：1.不会转大小写A 的ASCII为 66 （小） a的ASCII为98 （大）差32把小写转换成大写就是：if(a[i]>=’a’ &amp;&amp; a[i]&lt;=’z’)<br>{<br>    a[i]=a[i]-‘a’+’A’;  //a[i]=a[i]- (‘a’ - A)<br>}<br>把大写转换成小写就是：</p><p>if(a[i]&gt;=’A’ &amp;&amp; a[i]&lt;=’Z’)<br>{<br>    a[i]=a[i]-‘A’+’a’;<br>}</p><p>题目:小书童-凯撒密码<br><img src="pic/小书童——凯撒密码.png" alt="alt text"><br>c++<br>最终版本：</p><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;</p><p>int main(){<br>    string s;<br>    int n;<br>    cin&gt;&gt;n&gt;&gt;s;<br>    if(n &gt;0&amp;&amp;n &lt;27){<br>        for(int i = 0; i &lt; s.length();i++){<br>            if (islower(s[i])) {    //islower(s[i]) 是一个函数调用，用于检查字符 s[i] 是否为小写字母<br>                s[i] = ‘a’ + (s[i] - ‘a’ + n) % 26; //string 约等于 char[],所以可用数组的方法<br>            }<br>        }<br>    }<br>    cout&lt;&lt;s;<br>    return 0;<br>}</p><p>c语言</p><h1 id="include-4"><a href="#include-4" class="headerlink" title="include "></a>include <stdio.h></h1><p>int main(){<br>    int n;<br>    char str[100];<br>    scanf(“%d%s”,&amp;n,str);<br>    for(int i = 0; str[i] != ‘\0’;i++){<br>        str[i] = ‘a’ + (str[i] - ‘a’ + n) % 26; // 也可写为 putchar((in[j]-‘a’+n)%26+’a’);<br>    }<br>    printf(“%s”,str); //使没有显式使用第二个循环来输出字符串，但由于 C 语言的特性，C 字符串以 null 结尾（即以 \0 结尾），printf(“%s”, str); 会一直输出字符直到遇到 null 终止符为止。<br>    return 0;<br>}</p><p>错误原因：<br>1.没有想到z跳完之后要转到a的情况<br>2.没有想到检测小写，而是直接转小写，不符合题意<br>3.(str[i] - ‘a’ + n)写成(‘a’ - str[i]  + n) 小- 大导致错误<br>重点：<br>1.s[i] = ‘a’ + (s[i] - ‘a’ + n) % 26;<br>这行代码是用来实现对小写字母进行向后移动 n 位的操作。让我们解释一下这行代码的具体功能：<br>s[i] - ‘a’：这部分计算了当前字符 s[i] 相对于小写字母表中的字母 ‘a’ 的偏移量。<br>(s[i] - ‘a’ + n)：这一部分将偏移量加上移动的位数 n，以实现向后移动的效果。<br>(s[i] - ‘a’ + n) % 26：由于小写字母表只有 26 个字母，因此这一部分确保结果在 0 到 25 之间，以便在字母表上循环移动。<br>‘a’ + (s[i] - ‘a’ + n) % 26：最后，将结果映射回小写字母表，得到移动后的字符。<br>2.putchar()<br>putchar()是一个 C 语言标准库函数，用于将一个字符输出到标准输出流（通常是控制台）<br>eg:putchar(66) = printf(“A”)</p><p>必学方法：确保结果在 0 到 25 之间，利用 % 26得到!!!!!!</p><p>3.题目 笨小猴<br><img src="pic/笨小猴.png" alt="alt text"><br>代码：<br>正确版本：</p><h1 id="include-5"><a href="#include-5" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-6"><a href="#include-6" class="headerlink" title="include "></a>include <string></h1><h1 id="include-提供了对基本数学运算和函数的支持"><a href="#include-提供了对基本数学运算和函数的支持" class="headerlink" title="include   //提供了对基本数学运算和函数的支持"></a>include <cmath>  //提供了对基本数学运算和函数的支持</h1><p>using namespace std;</p><p>//知识点2 素数的判断<br>bool isPrime(int num) { //bool表示布尔值的返回类型<br>    if (num &lt;= 1) return false;<br>    for (int i = 2; i &lt;= sqrt(num); i++) {  //sqrt(num)开方，即使根号2小于2，但是仍然把根号2，取到2来看待<br>        if (num % i == 0) return false;<br>    }<br>    return true;<br>}</p><p>int main() {<br>    string str;<br>    cin &gt;&gt; str;<br>    int n[26] = {0};</p><pre><code>// 统计每个字母出现的次数for (char c : str) &#123;    //知识点1 增强型for循环    n[c - &#39;a&#39;]++;&#125;int maxn = 0, minn = 100;  // 初始化minn为一个较大值// 找到最大和最小的非零频率for (int i = 0; i &lt; 26; i++) &#123;    if (n[i] &gt; 0) &#123;        if (n[i] &gt; maxn) maxn = n[i];        if (n[i] &lt; minn) minn = n[i];    &#125;&#125;int z = maxn - minn;// 根据z的值判断输出if (isPrime(z)) &#123;    cout &lt;&lt; &quot;Lucky Word&quot; &lt;&lt; endl &lt;&lt; z;&#125; else &#123;    cout &lt;&lt; &quot;No Answer&quot; &lt;&lt; endl &lt;&lt; 0;&#125;return 0;</code></pre><p>}</p><p>知识点：<br>1.增强型for循环（c++）<br>    1&gt;遍历字符串 string s;<br>        for( int i = 0; i &lt; s.length(); i++)：通常写法<br>        for (char c : s)：复制一个s字符串再进行遍历操作（慢）<br>        for (char&amp; c : s)：直接引用原字符串进行遍历操作（快）<br>    2&gt;遍历数组 int a[6] = { 3,2,1,4,9,0 };<br>        for (int i : a)<br>        for (int &amp;i : a) </p><p>2.素数的判断<br>bool isPrime(int num) {<br>    if (num &lt;= 1) return false;<br>    for (int i = 2; i &lt;= sqrt(num); i++) {<br>        if (num % i == 0) return false;<br>    }<br>    return true;<br>}</p><p>错误版本： 错误原因未知</p><h1 id="include-7"><a href="#include-7" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-8"><a href="#include-8" class="headerlink" title="include "></a>include <string></h1><h1 id="include-9"><a href="#include-9" class="headerlink" title="include"></a>include<algorithm></h1><h1 id="include-10"><a href="#include-10" class="headerlink" title="include "></a>include <cmath></h1><p>using namespace std;</p><p>int main(){<br>    string str;<br>    cin&gt;&gt;str;<br>    int n[25] = {0};<br>    int z;<br>    for(int i = 0; i &lt; str.size(); i++){<br>        n[str[i] - ‘a’]++;<br>    }<br>    sort(n, n + 26);<br>    /<em>for(int i = 0; i &lt; 26; i++){<br>        cout&lt;&lt;n[i];<br>    }</em>/<br>    for(int i = 0; i &lt; 26; i++){<br>        if(n[i] &gt; 0){<br>            z = n[25] - n[i];<br>            break;<br>        }<br>    }<br>    if(z == 2 || z==3){<br>        cout&lt;&lt;”Lucky Word”;<br>    }<br>    else if(z == 0||z == 1){<br>        cout&lt;&lt;”No Answer”;<br>    }<br>    else{<br>        int c = 0;<br>        for(int i = 2; i &lt;= sqrt(z);i++){<br>            if(z % i == 0){<br>                c = 1;<br>                break;<br>            }<br>        }<br>        if(c == 1) cout&lt;&lt;”No Answer”;<br>        else cout&lt;&lt;”Lucky Word”;<br>    }<br>    cout&lt;&lt;endl&lt;&lt;z;<br>    return 0;<br>}</p><p>题目：口算练习题<br><img src="pic/口算练习题.png" alt="alt text"></p><p>代码：</p><h1 id="include-11"><a href="#include-11" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-12"><a href="#include-12" class="headerlink" title="include "></a>include <string></h1><h1 id="include-13"><a href="#include-13" class="headerlink" title="include"></a>include<algorithm></h1><h1 id="include-14"><a href="#include-14" class="headerlink" title="include "></a>include <cmath></h1><h1 id="include-15"><a href="#include-15" class="headerlink" title="include"></a>include<cstring></h1><p>using namespace std;</p><p>int main(){<br>    int i;<br>    cin&gt;&gt;i; //input amount of data<br>    int x,y; //two caozuoshu<br>    char z,f; //z is the last sign ,f is the new sign or data<br>    while(i&gt;0){<br>        i—;<br>        char s1[100];<br>        char s[100];<br>        scanf(“%s”,&amp;s1);<br>        if(s1[0] == ‘a’||s1[0] == ‘b’||s1[0] == ‘c’){<br>            z = s1[0];<br>            scanf(“%d%d”,&amp;x,&amp;y);<br>        }<br>        else{<br>            x = atoi(s1);   //知识点1<br>            scanf(“%d”,&amp;y);<br>        }<br>        if(z == ‘a’){<br>            sprintf(s,”%d+%d=%d”,x,y,x+y);<br>        }<br>        else if(z == ‘b’){<br>            sprintf(s,”%d-%d=%d”,x,y,x-y);<br>        }<br>        else if(z == ‘c’){<br>            sprintf(s,”%d<em>%d=%d”,x,y,x</em>y);<br>        }<br>        //cout&lt;<endl<<strlen(s);        printf("%s\n%d\n",s,strlen(s));    }    return 0;}知识点：1.字符转数字 1>stoi()<br>    将字符串转换为int型<br>    针对于string类型的(char也行)。stoi函数是C++11引入的，因此只有在C++11及以上的版本中才能使用该函数<br>    同理stol()、stof()、stod(),分别将字符串类型转换成long long、float、double类型</p><p> 2&gt;atoi()<br>    toi()函数是C语言中的一个函数，主要用于将字符串转换为整数。针对于字符数组,类似的还有atol()、atof()、atod()</p><p> 3&gt;利用ASCII</p><pre><code>#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char ch[]=&#123;&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;&#125;;int main()&#123;    for(int i=0;i&lt;strlen(ch);i++)&#123;        cout&lt;&lt;ch[i]-&#39;0&#39;&lt;&lt;&quot; &quot;; //重点    &#125;    return 0;&#125;</code></pre><p> 4&gt;stringstream<br>    stringstream是C++中的一个类，可以用来对字符串进行输入输出操作<br>    它是基于字符串的流，可以用来将字符串转换为其他类型的数据，以及将其他类型的数据转换为字符串。stringstream类的头文件是<sstream>，我们需要包含这个头文件才能使用stringstream类。<br>    eg:</p><pre><code>#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;typeinfo&gt;using namespace std;int main()&#123;stringstream ss;string s=&quot;12345&quot;;int num;ss&lt;&lt;s;//将字符串读入字符串流 ss&gt;&gt;num;//从字符串流中读取数据转换为整数cout&lt;&lt;typeid(num).name()&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;endl;return 0; &#125;</code></pre><p>2.数字转为字符串<br>    1&gt;利用ASCII<br>    字符转数字可以-‘0’，数字转字符那么就可以+’0’<br>    cout&lt;&lt;nums[i]+’0’&lt;&lt;” “;</p><pre><code>2&gt;to_string()用于将不同类型的数据转换为字符串可以将int、float、double、long long等类型转换为string类型。需要包含头文件#include&lt;cstring&gt;（c++）3&gt;itoa()toa函数用于将整数转换为字符串。类似的还有ltoa、ftoa、dtoa分别将long long、float、double转换为字符串类型。针对于字符数组4&gt;stringstream</code></pre><h1 id="include-16"><a href="#include-16" class="headerlink" title="include"></a>include<iostream></h1><h1 id="include-17"><a href="#include-17" class="headerlink" title="include"></a>include<sstream></h1><h1 id="include-18"><a href="#include-18" class="headerlink" title="include"></a>include<cstring></h1><h1 id="include-19"><a href="#include-19" class="headerlink" title="include"></a>include<typeinfo></h1><p>using namespace std;<br>int main(){<br>    stringstream ss;<br>    string s=”12345”;<br>    int num=54321;<br>    ss&lt;&lt;num;//将int类型的数据写入字符串流中<br>    s=ss.str();//将字符串流中的数据转换为string类型<br>    cout&lt;&lt;typeid(s).name()&lt;&lt;” “&lt;&lt;num&lt;&lt;endl;<br>    return 0;<br>}</p><p>3.sscanf()和sprintf()<br>实现数据与字符串之间的转换</p><p>sscanf()作用：<br>（1）根据格式从字符串中提取数据。如从字符串中取出整数、浮点数和字符串等。<br>（2）取指定长度的字符串<br>（3）取到指定字符为止的字符串<br>（4）取仅包含指定字符集的字符串<br>（5）取到指定字符集为止的字符串<br>sscanf可以支持格式字符%[]：<br>(1)-: 表示范围，如：%[1-9]表示只读取1-9这几个数字 %[a-z]表示只读取a-z小写字母，类似地 %[A-Z]只读取大写字母<br>(2)^: 表示不取，如：%<sup><a href="#fn_1" id="reffn_1">1</a></sup>表示读取除’1’以外的所有字符 %<sup><a href="#fn_/" id="reffn_/">/</a></sup>表示除/以外的所有字符<br>(3),: 范围可以用”,”相连接 如%[1-9,a-z]表示同时取1-9数字和a-z小写字母<br>(4)原则：从第一个在指定范围内的数字开始读取，到第一个不在范围内的数字结束%s 可以看成%[] 的一个特例 %<a href="注意^后面有一个空格！">^ </a></p><p>sprintf()作用：<br> 1     char str[256] = { 0 };<br> 2     int data = 1024;<br> 3     //将data转换为字符串<br> 4     sprintf(str,”%d”,data);</p><p> 5     //获取data的十六进制<br> 6     sprintf(str,”0x%X”,data);<br> 7     //获取data的八进制<br> 8     sprintf(str,”0%o”,data);<br> 9     const char <em>s1 = “Hello”;<br>10     const char </em>s2 = “World”;<br>11     //连接字符串s1和s2<br>12     sprintf(str,”%s %s”,s1,s2);</p><p>4.strlen(s)</p><p>易错点：<br>char ss[100],并不意味着ss的长度就是100，而是界限为100，用strlen(s)来求取长度</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1.差值</title>
      <link href="/posts/ac608bef.html"/>
      <url>/posts/ac608bef.html</url>
      
        <content type="html"><![CDATA[<p>题目：D:\hexo\heo\source_posts\练习题\牛客\pic-牛客\1.差值.png<br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <cmath></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <algorithm></h1><p>using namespace std;</p><p>int main(){<br>    int n;<br>    int c = 1000000;<br>    cin&gt;&gt;n; //输入战士数量<br>    int zl[n - 1];<br>    for(int i = 0; i &lt; n; i++){<br>        cin&gt;&gt;zl[i];<br>    }    //输入战力<br>    sort(zl, zl + n); //知识点1<br>    for(int i = 0; i &lt; n - 1; i++){<br>        c = abs(zl[i] - zl[i + 1]) &lt; c ? abs(zl[i] - zl[i + 1]) : c;    //知识点2<br>        if(c == 0) break;<br>    }<br>    cout&lt;&lt;c;<br>    return 0;<br>}</p><p>知识点：<br>1.排序c++ sort()<br>用法：sort(begin, end, cmp)<br>    begin为指向待sort()的数组的第一个元素的指针<br>    end为指向待sort()的数组的最后一个元素的下一个位置的指针<br>    cmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序。如果我们想从大到小排序可以将cmp参数写为greater<int>()就是对int数组进行排序，当然&lt;&gt;中我们也可以写double、long、float等等<br>    eg：sort(num,num+10,greater<int>());//大到小<br>        sort(zl, zl + n);一般情况，数组大小为多少就加多少，比如zl[5],则sort(zl,zl + 5)<br>头文件：#include <algorithm></p><p>2.绝对值<br>C++中不同的数据类型需要使用不同的绝对值函数：<br>对于整型(int)，使用abs()函数。<br>对于复数类型(complex)，使用cabs()函数来获取复数的模。<br>对于双精度浮点型(double)，使用fabs()函数。<br>对于长整型(long)，使用labs()函数。<br>头文件：C++ #include <cmath>    C #include<math.h></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2.删除公共字符</title>
      <link href="/posts/22b2968b.html"/>
      <url>/posts/22b2968b.html</url>
      
        <content type="html"><![CDATA[<p>题目：<br><img src="pic-牛客/2.删除公共字符.png" alt="alt text"><br>代码：</p><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <iostream></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <string></h1><p>using namespace std;<br>//没有要求大小写 所以没做出说明<br>int main(){<br>    string str1,str2;<br>    getline(cin,str1);<br>    cin&gt;&gt;str2;<br>    for(int i = 0; i &lt; str2.size();i++){<br>        int pos = str1.find(str2[i]);<br>        while(pos &gt;= 0){<br>            str1 = str1.erase(pos,1); //知识点1<br>            pos = str1.find(str2[i]);<br>        }<br>    }<br>    cout&lt;<str1;    return 0;}知识点：1.str1.erase(pos,1);作用：删除string字符串str1里pos位置（从0开始数），的n个字符（这里N直接用的1）（包括pos位置）头文件：#include <string></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode-02-跳跃游戏2</title>
      <link href="/posts/1ce411cd.html"/>
      <url>/posts/1ce411cd.html</url>
      
        <content type="html"><![CDATA[<p>int jump(int<em> nums, int numsSize) {<br>    /</em><br>    思路：<br>    1.都是从0开始，所以maxlength = 0，每跳跃一次，遍历从index = 0到index = nums[i]，即这一次所能跳跃最大距离的所有的元素，判断跳跃这一 次所到达的最远距离，更新maxlength,以此类推，直至maxlength &gt;= numsSize - 1<br>    */<br>    int maxlength = nums[0];<br>    int amount = 0;</p><pre><code>if(numsSize == 1)&#123;    return amount;&#125;if (maxlength  &gt;= numsSize - 1)&#123;        return amount + 1;    &#125;/*for(int i = 0; i &lt; numsSize; i++)&#123;    for(int j = i + 1; j &lt;= i + nums[i]; j++)&#123;        if(j == numsSize - 1)&#123;            return amount + 1;        &#125;        maxlength = maxlength &gt; nums[j] + j ? maxlength : nums[j] + j;    &#125;    amount = amount + 2;    if (maxlength  &gt;= numsSize - 1)&#123;        return amount;    &#125;    i = maxlength - 1;&#125;return amount;*/int i = 0;while(maxlength  &lt; numsSize - 1)&#123;     for(int j = i + 1; j &lt;= i + nums[i]; j++)&#123;        if(j == numsSize - 1)&#123;            return amount + 1;        &#125;        maxlength = maxlength &gt; nums[j] + j ? maxlength : nums[j] + j;    &#125;    amount = amount + 2;    i = maxlength;&#125;return amount;</code></pre><p>}</p><p>int jump(int* nums, int numsSize) {<br>    int maxlength = nums[0];<br>    long amount = 0; // 将 amount 的类型改为 long</p><pre><code>if(numsSize == 1) &#123;    return amount;&#125;int i = 0;while (maxlength &lt;= numsSize - 1) &#123;    for (int j = i + 1; j &lt;= i + nums[i]; j++) &#123;        if (j == numsSize - 1) &#123;            return amount + 1;        &#125;        maxlength = maxlength &gt; nums[j] + j ? maxlength : nums[j] + j;        if (maxlength &gt;= numsSize - 1) &#123;            return amount + 2;        &#125;    &#125;    amount = amount + 2;    i = maxlength;&#125;return amount;</code></pre><p>}</p><p>从当前元素开始，遍历该元素值范围内能遍历的所有元素，判断选择哪个元素实现下一步走的最远<br>每遍历一个，计算一次选择该元素能到达的最远距离（下标加元素值）<br>eg:{2 3 1 1 4 6 2 1}<br>从2的下一个元素3开始遍历，选择3时，最远到达1 + 3 = 4，选择1时，最远能到达2 + 1 = 3，最远到达1，遍历结束，以4作为下一次遍历的开始<br>从4的下一个元素6开始遍历，选择6时，最远能到达5 + 6 = 11，选择2时……  !!!不足点 已经达到结束条件，还要继续循环</p><p>int max(int a, int b) {<br>    return a &gt; b ? a : b;<br>}<br>int jump(int* nums, int numsSize) {<br>    int maxReach = 0; // 当前位置能到达的最远距离<br>    int steps = 0; // 跳跃次数<br>    int end = 0; // 当前跳跃范围的边界 上一次跳跃的的终点 第一次跳跃上一次的终点即为0</p><pre><code>for (int i = 0; i &lt; numsSize - 1; i++) &#123;    maxReach = max(maxReach, i + nums[i]);// 更新当前位置能到达的最远距离    if (i == end) &#123; // 如果到达当前跳跃范围的边界        end = maxReach; // 更新下一次跳跃的边界为当前位置能到达的最远距离        steps++; // 增加跳跃次数    &#125;&#125;return steps;</code></pre><p>}<br>eg:{2 3 1 1 4 6 2 1}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode-02-跳跃游戏1</title>
      <link href="/posts/871adf45.html"/>
      <url>/posts/871adf45.html</url>
      
        <content type="html"><![CDATA[<p>题目描述：<br>解题：<br>法一：超越时间限制<br>bool canJump(int<em> nums, int numsSize) {<br>    /</em><br>    题目理解：<br>    目的：从nums[0]跳到nums[numsSize - 1] 约束：跳跃长度jumplength &lt;= nums[pos] pos:当前数组元素下标<br>    目标：如果可以达到目的 跳跃次数 越少越好 否则输出false<br>    特殊点：<br>    1.nums[pos] = 0 &amp;&amp; pos &lt; numsSize - 1<br>    2.不满足跳到最后的条件：<br>        1&gt; 总会到达跳跃长度为0的下标<br>    思路：<br>    1.跳过nums[pos] = 0 &amp;&amp; pos &lt; numsSize - 1的数组元素<br>    2.减少跳跃次数</p><pre><code>思路2：判断如何从nums[0]跳到跳跃长度为0的下标，能找到输出false,否则输出true1.遍历数组，找到nums[pos] = 0的pos思路3：只要能找到一条跳到nums[numsSize - 1]的路，能找到输出true,否则输出false1.pos = 0 从nums[pos]开始，每次跳跃nums[pos]，2.如果nums[pos] = 0 回到上一个位置space    if nums[space] &gt;= 2 则 pos = pos + nums[pos] - 1,否则继续退到上一个位置3.如果pos + nums[pos] &gt;= numsSize - 1 返回true*/if(nums[0] == 0 &amp;&amp; numsSize != 1)&#123;    return false;&#125;else if(nums[0] == 0 &amp;&amp; numsSize == 1)&#123;    return true;&#125;int pos = 0;int amount = 0;while(pos &lt;= numsSize - 1 &amp;&amp; pos &gt;= 0)&#123;    int space = nums[pos];  //  记录上一次走的步长    pos = pos + nums[pos];    amount++;    if(pos &lt; numsSize - 1 &amp;&amp; nums[pos] == 0 )&#123;        if(space &gt; 1 &amp;&amp; amount &gt; 0)&#123;            pos = pos - space - 1;        &#125;        else&#123;            if(amount &gt; 0)&#123;                pos = pos - 1;                amount--;            &#125;            for(int i = amount; i &gt; 0; i--)&#123;                pos = pos - nums[i];                if(pos &gt;= 0 &amp;&amp; nums[pos] &gt; 1)&#123;                    pos = pos + nums[pos] - 1;                &#125;                else if (pos = 0)&#123;                    return false;                &#125;            &#125;        &#125;    &#125;&#125;if(pos &gt;= numsSize - 1)&#123;    return true;&#125;else&#123;    return false;&#125;</code></pre><p>}<br>法二：<br>bool canJump(int<em> nums, int numsSize) {<br>    /</em>思路：<br>        目的：跳到最后一个元素numsSize - 1，只要能跳跃的最大长度大于等于numsSize - 1就能到达<br>    */<br>    if(numsSize == 1){<br>        return  true;<br>    }<br>    int reachmax = 0;<br>    for(int i = 0; i &lt; numsSize - 1; i++){<br>        if(nums[i] == 0 &amp;&amp; reachmax &lt;= i){<br>            return false;<br>        }<br>        reachmax =  reachmax &gt; i + nums[i] ? reachmax : i + nums[i];<br>        if(reachmax &gt;= numsSize - 1){<br>            return true;<br>        }<br>    }<br>    return false;<br>}<br>体会：<br>利用贪心算法寻找局部最优解<br>具体做法：每走一步就找寻一次最优解，直至找到最后<br>例如，在该问题中，走到index 0，更新一次能够走的最大距离，继续顺序走index 2，判断在index 2能走的最大距离，以此类推</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法-01-贪心算法1-Djikstra算法</title>
      <link href="/posts/90b623e1.html"/>
      <url>/posts/90b623e1.html</url>
      
        <content type="html"><![CDATA[<p>贪心算法:寻找局部最优解<br>大概有两种方法：Djikstra算法（迪杰斯特拉算法） 最小生成树Prim算法<br>Djikstra算法 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LeeCode 01-坐上公交的最晚时间</title>
      <link href="/posts/828b5000.html"/>
      <url>/posts/828b5000.html</url>
      
        <content type="html"><![CDATA[<p>问题描述：给你一个下标从 0 开始长度为 n 的整数数组 buses ，其中 buses[i] 表示第 i 辆公交车的出发时间。同时给你一个下标从 0 开始长度为 m 的整数数组 passengers ，其中 passengers[j] 表示第 j 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p><p>给你一个整数 capacity ，表示每辆公交车 最多 能容纳的乘客数目。</p><p>每位乘客都会排队搭乘下一辆有座位的公交车。如果你在 y 时刻到达，公交在 x 时刻出发，满足 y &lt;= x  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。</p><p>返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。</p><p>注意：数组 buses 和 passengers 不一定是有序的。</p><p>示例：<br>示例 1：</p><p>输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2<br>输出：16<br>解释：<br>第 1 辆公交车载着第 1 位乘客。<br>第 2 辆公交车载着你和第 2 位乘客。<br>注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。<br>示例 2：</p><p>输入：buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2<br>输出：20<br>解释：<br>第 1 辆公交车载着第 4 位乘客。<br>第 2 辆公交车载着第 6 位和第 2 位乘客。<br>第 3 辆公交车载着第 1 位乘客和你。</p><p>提示：</p><p>n == buses.length<br>m == passengers.length<br>1 &lt;= n, m, capacity &lt;= 105<br>2 &lt;= buses[i], passengers[i] &lt;= 109<br>buses 中的元素 互不相同 。<br>passengers 中的元素 互不相同 。</p><p>本人做法：<br>int latestTimeCatchTheBus(int<em> buses, int busesSize, int</em> passengers, int passengersSize, int capacity) {<br>   /*<br>   总思路</p><ol><li>排序 将buses,passages数组从小到大排序</li><li>最晚时间到达 即<br>1&gt; 选择到达时间最晚的公交 即下标为N-1的数组<br>2&gt; 按照乘客到达的时间从早到晚依次将busessize-1量公交车乘客安排完毕<br>3&gt; 继续安排最后一辆公交车的乘客<br><em>/<br>/</em><br>子问题一 排序 冒泡排序<br>1.依次比较i i+1两个元素的大小<br>1.1 若i &gt; i + 1,返回1<br>1.2 若i &lt; i + 1,交换二者位置<br>2.循环 n - 1 <em> n - 1次</em>/<br>/<em><br>问题二 安排乘客<br>1.从下标i = 0 i&lt;busesSize-2 外层,j = 0 内层 开始<br>2.若</em>(buses + i)&gt;*(passengers + j)</li><li>j+1 z+1</li><li><p>z==capacity或乘客不符合条件 i + 1<br>*/</p><p>int time; //最晚到达时间<br>int lasttime; //原本最后一位乘客的抵达时间</p><p>for(int j = 0; j &lt; busesSize - 1; j++) {  //公交车抵达时间排序<br>for(int i = 0; i &lt; busesSize - 1 - j; i++) {<br>  if(<em>(buses + i) &lt; </em>(buses + i + 1)) {</p><pre><code>  continue;</code></pre><p>  }<br>  else {</p><pre><code>  int z = *(buses + i);  *(buses + i) = *(buses + i + 1);  *(buses + i + 1) = z;</code></pre><p>  }<br>}<br>}<br>for(int j = 0; j &lt; passengersSize - 1; j++) {    //乘客到达时间排序<br>for(int i = 0; i &lt; passengersSize - 1 - j; i++) {<br>  if(<em>(passengers + i) &lt; </em>(passengers + i + 1)) {</p><pre><code>  continue;</code></pre><p>  }<br>  else {</p><pre><code>  int z = *(passengers + i);  *(passengers + i) = *(passengers + i + 1);  *(passengers + i + 1) = z;</code></pre><p>  }<br>}<br>}<br>int j1 = 0;<br>int i = 0;<br>int q = capacity;<br>for(i = 0; i &lt;= busesSize-2; i++){  //除最后一辆车外安排好其余乘客 j表示倒数第二辆车的最后一位乘客下标<br>  for(q = capacity; q &gt; 0; q—){</p><pre><code>  if(*(passengers + j1) &lt; *(buses + i))&#123;   //如果乘客到达时间小于公交车到达时间      j1++;  &#125;  else&#123;      break;  &#125;</code></pre><p>  }<br>}<br>int j = j1 - 1;</p><p>if(passengersSize - j1 &gt;=capacity){<br>  for(int c = capacity; c &gt; 0; c—){</p><pre><code>  if(*(passengers + j + c) - 1 != *(passengers + j + c - 1))&#123;      time = *(passengers + j + c) - 1;      break;  &#125;  else if(c == 1)&#123;      time = *(passengers + j + 1) - 1;  //极端情况，安排乘客抵达时间在第一个乘客前      break;  &#125;</code></pre><p>  }<br>}</p><p>return time;</p></li></ol><p>}</p><p>官方解答：<br>int compare(const void <em>a, const void </em>b) {<br>    return (<em>(int</em>)a - <em>(int</em>)b);<br>}</p><p>int latestTimeCatchTheBus(int<em> buses, int busesSize, int</em> passengers, int passengersSize, int capacity) {<br>    qsort(buses, busesSize, sizeof(int), compare);  //公交车到达时间排序<br>    qsort(passengers, passengersSize, sizeof(int), compare);    //乘客到达时间排序<br>    int pos = 0;    //第pos位乘客上车<br>    int space = 0;  //公交车容量</p><pre><code>for (int i = 0; i &lt; busesSize; i++) &#123;    int arrive = buses[i];  //第i（从0开始计数）量车情况    space = capacity;   //每辆公交车初始容量为capacity    while (space &gt; 0 &amp;&amp; pos &lt; passengersSize &amp;&amp; passengers[pos] &lt;= arrive) &#123;        //乘客上车条件：如果剩余容量&gt;0,还有乘客未走，以及乘客抵达时间&lt;=公交车到达时间        //反之若不满足任意条件，即，该辆公交车容量已满，或已经没有乘客，或乘客到达时间晚于公交车时间，跳出循环，转为下一辆车        space--;        pos++;        //在比较完下标为0的乘客时，pos = 1,已经指向下一位乘客数组下标，所以比到最后一位时，pos的值也会比下标大1，代表走了第几位（1开始计数）乘客    &#125;&#125;pos--;  //指向最后一位上车乘客的元素int lastCatchTime = space &gt; 0 ? buses[busesSize - 1] : passengers[pos];//space也可代表最后一辆公交车的剩余容量情况while (pos &gt;= 0 &amp;&amp; passengers[pos] == lastCatchTime) &#123;    pos--;    lastCatchTime--;&#125;return lastCatchTime;</code></pre><p>}</p><p>代码解读：</p><p>qsort — 用于数组排序的函数 英语quick sort快速排序<br>一、头文件 </p><h1 id="include"><a href="#include" class="headerlink" title="include"></a>include<stdlib.h></h1><p>二、格式<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(int</em>)a-<em>(int</em>)b;<br>}<br>qsort(num, n, sizeof(int), cmp);<br>包含四个参数(数组名, 数组长度，数组元素数据类型所占字节，排序原则)<br>使用方法：<br>定义一个函数cmp(自命名)，通过cmp返回的参数确定排序规则，其中cmp函数的参数需要以(const void <em>a,consi void </em>b)的形式定义，表示a,b变量的数据类型未知，在return返回时，用强制类型转换转换为int型，<em>(int</em>)a - <em>(int</em>)b 表示递增顺序,同理，<em>(int</em>)b - <em>(int</em>)a 表示递减顺序<br>排序原则：<br>根据要排序数组元素数据类型的不同，可分为四种<br>1.int型<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(int</em>)a-<em>(int</em>)b;<br>}<br>2.double型<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(double</em>)a&gt;<em>(double</em>)b?1:-1;<br>}<br>需要注意浮点数会存在精度损失的问题，所以我们需要通过比较，来返回1或-1，以确定是增序还是降序。<br>3.char型<br>int cmp(const void <em>a,const void </em>b) {<br>    return <em>(char</em>)a-<em>(char</em>)b;<br>}<br>4.结构体型<br>struct node{<br>    int i;<br>    double j;<br>    char k;<br>};<br>int cmp(const void <em>a,const void </em>b) {<br>    return (<em>(node</em>)a).i-(<em>(node</em>)b).i;<br>}<br>深度剖析：<br>void qsort(void<em> base, //指向了待排序数组的第一个元素<br>           size_t num,   //待排序的元素个数<br>           size_t size, //每个元素的大小，单位是字节<br>           int (</em> cmp)(const void<em>, const void</em>) //指向一个函数，这个函数可以比较2个元素的大小<br>          );<br>返回类型void:我们改变的是数列的排序，实际只需要进行内存的操作，所以不需要返回值。<br>void<em> base:表示应传入初始地址，至于为什么是void类型，它不知道我们会传入什么数据，而void类型就像一个垃圾桶一样什么地址都可以仍进去，所以只能用void</em>类型。<br>size_t num:num数量，表示应传入的元素个数<br>size_t width:width宽度，表示应传入的每个元素占的字节大小<br>int (<em>cmp)(const void </em>, const void *):<br>应传入一个比较函数地址，用于比较两个数据的大小，因为传入的数据类型是不确定的，所以我们需要自己定义一个比较函数传到qsort比较函数里面去，以便它知道怎么样去比较两个数据的大小。</p><p>qsort可以排序任意类型的数据<br>比较2个整数的大小，&gt; &lt; ==<br>比较2个字符串的大小，strcmp<br>比较2个结构体数据（学生：张三，李四）指定比较的标准</p><p>const void <em>a<br>关键字 const<br>作用：用const修饰的变量或对象的值不能再被改变<br>根据数据类型的不同分为：<br>1.修饰普通变量<br>const int n=5;<br>注意：用const修饰变量时，一定要给变量初始化，否则之后不能再进行赋值<br>int const n=5;<br>两种情况，n的值都不能再被改变<br>2.修饰指针<br>    1&gt;常量指针：指针指向的内容是常量<br>        const int </em> n;<br>        int const <em> n;<br>    注意：仅仅指 指针指向的内容为常量，相当于，常量指针指向哪个变量，哪个变量的值不能被改变，但是不能通过这个指针改变变量的值，但还是可以通过其他的引用来改变变量的值 【存疑-那常量指针的意义在哪】<br>        int a=5;<br>        const int</em> n=&a;<br>        a=6;<br>    2&gt;指针常量：指针自己是常量，即只能指向一个地址，但指向的内容可以改变<br>        int a=5;<br>        int <em>p=&a;<br>        int</em> const n=&a;<br>        <em>p=8;<br>区分指针常量，常量指针：字面翻译<br>    const int </em> n; 先常量后指针，常量指针<br>    int* const n=&a; 先指针后常量，指针常量，指针（是）常量</p><p><em>(int</em>)a-<em>(int</em>)b<br>    (int*)a :强制类型转换，将a的数据类型强制转换成整型指针<br>    强制类型转换：(type_name) expression 即 (要转换的目标类型)被转换的变量或表达式</p><p>学习心得：<br>循环条件有顺序，eg:while (pos &gt;= 0 &amp;&amp; passengers[pos] == lastCatchTime) 判断完第一个条件符合后才进行第二个条件<br>所以必要的边界条件先写，再写后面的逻辑约束条件</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;  }    div#menus {    font-family: "ZhuZiAYuanJWD";  }  h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;  }  a.article-title,  a.blog-slider__title,  a.categoryBar-list-link,  h1.post-title {    font-family: ZhuZiAYuanJWD;  }    .iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;  }    /* 时间轴生肖icon */  svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;  }    .icon-zhongbiao::before {    color: #f7c768;  }    /* bilibli番剧插件 */  #article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;  }  a.bangumi-tab:hover {    text-decoration: none !important;  }  .bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;  }  a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;  }  .bangumi-button {    padding: 5px 10px !important;  }    a.bangumi-tab {    padding: 5px 10px !important;  }  svg.icon.faa-tada {    font-size: 1.1em;  }  .bangumi-info-item {    border-right: 1px solid #f2b94b;  }  .bangumi-info-item span {    color: #f2b94b;  }  .bangumi-info-item em {    color: #f2b94b;  }    /* 解决artitalk的图标问题 */  #uploadSource > svg {    width: 1.19em;    height: 1.5em;  }    /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */  #page-header:not(.not-top-img):before {    background-color: transparent !important;  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);  }    /* 文章页面正文背景 */  div#post {    background: rgba(255, 255, 255, 0.9);  }    /* 分页页面 */  div#page {    background: rgba(255, 255, 255, 0.9);  }    /* 归档页面 */  div#archive {    background: rgba(255, 255, 255, 0.9);  }    /* 标签页面 */  div#tag {    background: rgba(255, 255, 255, 0.9);  }    /* 分类页面 */  div#category {    background: rgba(255, 255, 255, 0.9);  }    /*夜间模式伪类遮罩层透明*/  [data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;  }    [data-theme="dark"] .card-widget {    background: #121212 !important;  }    [data-theme="dark"] div#post {    background: #121212 !important;  }    [data-theme="dark"] div#tag {    background: #121212 !important;  }    [data-theme="dark"] div#archive {    background: #121212 !important;  }    [data-theme="dark"] div#page {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: #121212 !important;  }    [data-theme="dark"] div#category {    background: transparent !important;  }  /* 页脚透明 */  #footer {    background: transparent !important;  }    /* 头图透明 */  #page-header {    background: transparent !important;  }    #rightside > div > button {    border-radius: 5px;  }    /* 滚动条 */    ::-webkit-scrollbar {    width: 10px;    height: 10px;  }    ::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;  }    ::-webkit-scrollbar-corner {    background-color: transparent;  }    ::-moz-selection {    color: #fff;    background-color: #3b70fc;  }    /* 音乐播放器 */    /* .aplayer .aplayer-lrc {    display: none !important;  } */    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */  }    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */  }    .aplayer.aplayer-fixed {    z-index: 999999 !important;  }    /* 评论框  */  .vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;  }    /* 设置评论框 */    .vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;  }    /* md网站下划线 */  #article-container a:hover {    text-decoration: none !important;  }    #article-container #hpp_talk p img {    display: inline;  }    /* 404页面 */  #error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);  }    #error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;  }    #error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;  }    #error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;  }  #error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;  }  #error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;  }  #error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);  }    #body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;  }    #body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;  }    #body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;  }    #body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;  }    #body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;  }    #body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;  }    #body-wrap.error .aside-list .aside-list-item .content time {    display: none;  }    /* 代码框主题 */  #article-container figure.highlight {    border-radius: 10px;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ail_font.js"/>
      <url>/js/ail_font.js</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
